<!DOCTYPE html>
<html>
<head>
    <title>Journey Buddy ü¶Ü</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F4FF 100%);
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }
        
        canvas { display: block; }
        
        #ui { z-index: 10; }
        
        /* UI Overlay */
        #ui {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }
        
        #ui * { pointer-events: auto; }
        #center-area { pointer-events: none; }
        #setup-panel, #celebration, #summary-panel { pointer-events: auto; }
        
        /* Header */
        #header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #header h1 {
            font-size: 1.3rem;
            color: #2D5A27;
            text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        }
        #timer-display {
            font-size: 2rem;
            font-weight: bold;
            color: #FF6B35;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-variant-numeric: tabular-nums;
        }
        
        /* Center area - for messages */
        #center-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        /* Setup panel */
        #setup-panel {
            background: white;
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            text-align: center;
            max-width: 320px;
            margin: 20px;
            position: relative;
            z-index: 100;
        }
        #setup-panel h2 {
            color: #333;
            font-size: 1.4rem;
            margin-bottom: 8px;
        }
        #setup-panel p {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
        #theme-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .theme-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 3px solid transparent;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 3px rgba(0,0,0,0.5);
        }
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.selected { border-color: #4CAF50; box-shadow: 0 2px 8px rgba(76,175,80,0.4); }
        .theme-btn.forest { background: linear-gradient(135deg, #4CAF50, #2E7D32); }
        .theme-btn.desert { background: linear-gradient(135deg, #D4A574, #A67B5B); }
        .theme-btn.ocean { background: linear-gradient(135deg, #42A5F5, #1976D2); }
        .theme-btn.winter { background: linear-gradient(135deg, #78909C, #546E7A); }
        
        #activity-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 15px 0;
        }
        .activity-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            border: 2px solid #E8F5E9;
            border-radius: 16px;
            background: #FAFAFA;
            cursor: pointer;
            transition: all 0.2s;
        }
        .activity-btn:hover, .activity-btn:active {
            border-color: #4CAF50;
            background: #E8F5E9;
            transform: scale(1.02);
        }
        .activity-btn .emoji {
            font-size: 1.8rem;
            margin-bottom: 4px;
        }
        .activity-btn .label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #333;
        }
        .activity-btn .time {
            font-size: 0.7rem;
            color: #888;
        }
        
        .btn {
            padding: 16px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active {
            transform: scale(0.96);
        }
        .btn-primary {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            box-shadow: 0 4px 15px rgba(76,175,80,0.4);
        }
        .btn-secondary {
            background: #f5f5f5;
            color: #666;
        }
        .btn-warning {
            background: linear-gradient(135deg, #FF9800, #F57C00);
            color: white;
            box-shadow: 0 4px 15px rgba(255,152,0,0.4);
        }
        
        /* Controls during journey */
        #journey-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }
        #journey-controls.visible { display: flex; gap: 15px; }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .control-btn:active { transform: scale(0.9); }
        #pause-btn {
            background: linear-gradient(135deg, #5C6BC0, #3F51B5);
            color: white;
        }
        #resume-btn {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            display: none;
        }
        
        /* Celebration banner */
        #celebration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
        }
        #celebration.visible { display: block; }
        #celebration h2 {
            font-size: 2.5rem;
            color: #FF6B35;
            text-shadow: 0 3px 6px rgba(0,0,0,0.1);
            animation: bounce 0.5s ease infinite alternate;
        }
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }
        #celebration p {
            font-size: 1.2rem;
            color: #666;
            margin-top: 10px;
        }
        
        /* Reward panel */
        #reward-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-radius: 24px 24px 0 0;
            padding: 25px;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.15);
            transform: translateY(100%);
            transition: transform 0.4s ease;
        }
        #reward-panel.visible { transform: translateY(0); }
        #reward-panel h3 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        #rewards-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        .reward-item {
            width: 80px;
            height: 80px;
            background: #FFF9C4;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: grab;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            user-select: none;
            -webkit-user-select: none;
        }
        .reward-item:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .reward-item.dragging {
            opacity: 0.5;
        }
        #drop-hint {
            text-align: center;
            color: #888;
            font-size: 0.85rem;
        }
        
        /* Dragging reward */
        #drag-reward {
            position: fixed;
            font-size: 3rem;
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }
        #drag-reward.visible { display: block; }
        
        /* Summary panel */
        #summary-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 340px;
            width: calc(100% - 40px);
            display: none;
        }
        #summary-panel.visible { display: block; }
        #summary-panel h2 {
            color: #4CAF50;
            margin-bottom: 5px;
        }
        #summary-panel .subtitle {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
        #rewards-chart {
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
            padding: 10px;
            background: #F5F5F5;
            border-radius: 12px;
        }
        .reward-row {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: white;
            border-radius: 8px;
            animation: popIn 0.3s ease;
        }
        .reward-row .activity-icon {
            font-size: 1.4rem;
            margin-right: 10px;
        }
        .reward-row .activity-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 500;
            color: #333;
        }
        .reward-row .reward-emoji {
            font-size: 1.4rem;
            margin-left: 8px;
        }
        .reward-row .reward-date {
            font-size: 0.7rem;
            color: #888;
            margin-left: 8px;
        }
        #total-rewards {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }
        @keyframes popIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* Timer celebration animation */
        #timer-display.celebrate {
            animation: timerCelebrate 1.5s ease;
        }
        @keyframes timerCelebrate {
            0% { transform: scale(1); color: #FF6B35; }
            10% { transform: scale(1.4) rotate(-3deg); color: #FFD700; }
            20% { transform: scale(1.5) rotate(3deg); color: #FF6B35; }
            30% { transform: scale(1.4) rotate(-2deg); color: #FFD700; }
            40% { transform: scale(1.3) rotate(2deg); color: #FF6B35; }
            60% { transform: scale(1.2) rotate(0deg); color: #FFD700; }
            100% { transform: scale(1) rotate(0deg); color: #FF6B35; }
        }
        #summary-panel .btn {
            margin-top: 15px;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui">
    <div id="header">
        <h1>ü¶Ü Journey Buddy</h1>
        <div id="timer-display">--:--</div>
    </div>
    
    <div id="center-area">
        <!-- Setup Panel -->
        <div id="setup-panel">
            <h2>What are we doing?</h2>
            <div id="theme-selector">
                <button class="theme-btn forest selected" onclick="selectTheme('forest')" title="Forest">üå≤</button>
                <button class="theme-btn desert" onclick="selectTheme('desert')" title="Desert">üèúÔ∏è</button>
                <button class="theme-btn ocean" onclick="selectTheme('ocean')" title="Ocean">üåä</button>
                <button class="theme-btn winter" onclick="selectTheme('winter')" title="Tundra">‚ùÑÔ∏è</button>
            </div>
            <div id="activity-grid">
                <div class="activity-btn" onclick="startActivity('toothbrush', 2)">
                    <span class="emoji">ü™•</span>
                    <span class="label">Brush Teeth</span>
                    <span class="time">2 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('dress', 5)">
                    <span class="emoji">üëï</span>
                    <span class="label">Get Dressed</span>
                    <span class="time">5 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('tidy', 5)">
                    <span class="emoji">üßπ</span>
                    <span class="label">Tidy Up</span>
                    <span class="time">5 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('eat', 10)">
                    <span class="emoji">üçΩÔ∏è</span>
                    <span class="label">Eat Meal</span>
                    <span class="time">10 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('read', 15)">
                    <span class="emoji">üìö</span>
                    <span class="label">Reading</span>
                    <span class="time">15 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('homework', 20)">
                    <span class="emoji">‚úèÔ∏è</span>
                    <span class="label">Homework</span>
                    <span class="time">20 min</span>
                </div>
                <div class="activity-btn" onclick="startActivity('calm', 3)">
                    <span class="emoji">üßò</span>
                    <span class="label">Calm Down</span>
                    <span class="time">3 min</span>
                </div>
                <div class="activity-btn" onclick="showCustomInput()">
                    <span class="emoji">‚≠ê</span>
                    <span class="label">Custom</span>
                    <span class="time">? min</span>
                </div>
            </div>
            
            <!-- Custom time input (hidden by default) -->
            <div id="custom-input" style="display: none; margin-top: 15px;">
                <input type="number" id="custom-minutes" min="1" max="60" value="5" 
                    style="width: 80px; padding: 12px; font-size: 1.5rem; text-align: center; border: 2px solid #4CAF50; border-radius: 12px;">
                <span style="font-size: 1rem; color: #666; margin-left: 8px;">minutes</span>
                <br>
                <button class="btn btn-primary" onclick="startCustomActivity()" style="margin-top: 12px;">üöÄ Start!</button>
                <button class="btn btn-secondary" onclick="hideCustomInput()" style="margin-top: 12px; margin-left: 8px;">Cancel</button>
            </div>
        </div>
        
        <!-- Celebration -->
        <div id="celebration">
            <h2>üéâ Amazing!</h2>
            <p>You and Buddy did it!</p>
        </div>
<!-- removed popup -->
        
        <!-- Summary -->
        <div id="summary-panel">
            <h2>üåü Great Job!</h2>
            <p class="subtitle">Buddy's Reward Chart</p>
            <div id="rewards-chart"></div>
            <div id="total-rewards"></div>
            <button class="btn btn-primary" onclick="resetApp()">Start New Journey</button>
        </div>
    </div>
    
    <!-- Journey Controls -->
    <div id="journey-controls">
        <div id="reset-btn-wrapper" style="position: relative; width: 70px; height: 70px;">
            <div id="reset-progress" style="position: absolute; inset: 0; border-radius: 50%; background: conic-gradient(#CC3333 0deg, transparent 0deg); opacity: 0; transition: opacity 0.2s;"></div>
            <button id="reset-btn" class="control-btn" style="position: absolute; inset: 4px; width: auto; height: auto; background: linear-gradient(135deg, #F5DEB3, #DEB887); color: #CC3333; font-weight: bold;">‚Üª</button>
        </div>
        <button id="pause-btn" class="control-btn" onclick="sleepDuck()">üò¥</button>
        <button id="resume-btn" class="control-btn" onclick="wakeDuck()">üîî</button>
    </div>
    
    <!-- Reward Panel -->
    <div id="reward-panel">
        <h3>Give Buddy a reward! üéÅ</h3>
        <div id="rewards-container">
            <div class="reward-item" data-reward="üéÄ">üéÄ</div>
            <div class="reward-item" data-reward="‚≠ê">‚≠ê</div>
            <div class="reward-item" data-reward="üé©">üé©</div>
        </div>
        <p id="drop-hint">Drag a reward to Buddy!</p>
    </div>
</div>

<div id="drag-reward"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// === STATE ===
let state = 'setup'; // setup, journey, paused, celebration, reward, summary
let totalSeconds = 300;
let remainingSeconds = 300;
let timerInterval = null;
let journeyStartTime = 0;
let pausedTime = 0;

// Weekly rewards (persisted in localStorage)
let weeklyRewards = JSON.parse(localStorage.getItem('buddyRewards') || '[]');

// === SOUND EFFECTS ===
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
}

function playQuack() {
    const ctx = initAudio();
    const now = ctx.currentTime;
    
    // Duck quack - two quick descending tones
    const osc1 = ctx.createOscillator();
    const gain1 = ctx.createGain();
    osc1.connect(gain1);
    gain1.connect(ctx.destination);
    osc1.frequency.setValueAtTime(800, now);
    osc1.frequency.exponentialRampToValueAtTime(400, now + 0.15);
    gain1.gain.setValueAtTime(0.3, now);
    gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    osc1.start(now);
    osc1.stop(now + 0.15);
    
    // Second quack
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.frequency.setValueAtTime(750, now + 0.18);
    osc2.frequency.exponentialRampToValueAtTime(350, now + 0.35);
    gain2.gain.setValueAtTime(0.25, now + 0.18);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
    osc2.start(now + 0.18);
    osc2.stop(now + 0.35);
}

function playCelebration() {
    const ctx = initAudio();
    const now = ctx.currentTime;
    
    // Happy fanfare - ascending notes
    const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
    notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.setValueAtTime(freq, now + i * 0.15);
        gain.gain.setValueAtTime(0.2, now + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.3);
        osc.start(now + i * 0.15);
        osc.stop(now + i * 0.15 + 0.3);
    });
    
    // Final chord
    [523, 659, 784, 1047].forEach((freq) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.setValueAtTime(freq, now + 0.7);
        gain.gain.setValueAtTime(0.15, now + 0.7);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
        osc.start(now + 0.7);
        osc.stop(now + 1.5);
    });
}

function playBell() {
    const ctx = initAudio();
    const now = ctx.currentTime;
    
    // Bell ring
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.setValueAtTime(1200, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.5);
    gain.gain.setValueAtTime(0.3, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    osc.start(now);
    osc.stop(now + 0.5);
}

// === CONFETTI ===
let confettiParticles = [];

function spawnConfetti() {
    const colors = [0xFF6B6B, 0xFFD93D, 0x4ECDC4, 0x9B59B6, 0xFF9FF3, 0x54A0FF, 0x5CD85C];
    
    for (let i = 0; i < 100; i++) {
        const confetti = new THREE.Mesh(
            new THREE.BoxGeometry(0.15 + Math.random() * 0.15, 0.15 + Math.random() * 0.15, 0.02),
            new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] })
        );
        confetti.position.set(
            duckBasePos.x + (Math.random() - 0.5) * 8,
            duckBasePos.y + 5 + Math.random() * 5,
            duckBasePos.z + (Math.random() - 0.5) * 8
        );
        confetti.userData = {
            velocityY: -0.02 - Math.random() * 0.03,
            velocityX: (Math.random() - 0.5) * 0.05,
            velocityZ: (Math.random() - 0.5) * 0.05,
            rotationSpeed: (Math.random() - 0.5) * 0.2,
            lifetime: 0
        };
        scene.add(confetti);
        confettiParticles.push(confetti);
    }
}

function updateConfetti() {
    confettiParticles.forEach((confetti, index) => {
        confetti.position.y += confetti.userData.velocityY;
        confetti.position.x += confetti.userData.velocityX;
        confetti.position.z += confetti.userData.velocityZ;
        confetti.rotation.x += confetti.userData.rotationSpeed;
        confetti.rotation.z += confetti.userData.rotationSpeed * 0.7;
        confetti.userData.lifetime++;
        
        // Remove after falling
        if (confetti.position.y < -2 || confetti.userData.lifetime > 300) {
            scene.remove(confetti);
            confettiParticles.splice(index, 1);
        }
    });
}

// Track minutes for quacking
let lastQuackMinute = 0;

function celebrateMinute() {
    const timer = document.getElementById('timer-display');
    timer.classList.remove('celebrate');
    
    // Trigger reflow to restart animation
    void timer.offsetWidth;
    timer.classList.add('celebrate');
    
    // Remove class after animation
    setTimeout(() => timer.classList.remove('celebrate'), 1500);
    
    // Also make duck do a little celebratory hop
    if (duck) {
        const originalY = duck.position.y;
        duck.position.y += 0.5;
        setTimeout(() => {
            if (duck) duck.position.y = originalY;
        }, 200);
    }
}

// === BIOME SYSTEM ===
const BIOMES = ['forest', 'desert', 'ocean', 'winter'];
let selectedBiome = 'forest'; // Default, user can change

const BIOME_CONFIG = {
    forest: {
        name: 'üå≤ Enchanted Forest',
        skyColor: 0x87CEEB,
        fogColor: 0x87CEEB,
        groundColors: ['#4a8f3a', '#5a9f4a', '#3a7f2a'],
        pathColor: 0xD4A574,
        ambient: 0.6,
        hasWater: true
    },
    desert: {
        name: 'üèúÔ∏è Sandy Desert',
        skyColor: 0xF5DEB3,
        fogColor: 0xDEB887,
        groundColors: ['#C9A066', '#B8956F', '#A67B5B'], // More brown/tan, less yellow
        pathColor: 0x8B7355,
        ambient: 0.85,
        hasWater: false
    },
    ocean: {
        name: 'üåä Ocean Adventure',
        skyColor: 0x87CEEB,
        fogColor: 0x6BB3D9,
        groundColors: ['#2E86AB', '#3498DB', '#1A5276'],
        pathColor: 0x5DADE2,
        ambient: 0.7,
        hasWater: true,
        isWater: true
    },
    winter: {
        name: '‚ùÑÔ∏è Frozen Tundra',
        skyColor: 0x8BA5B5,
        fogColor: 0x9BB5C5,
        groundColors: ['#A8B8C8', '#8899AA', '#778899'], // Rocky gray-blue
        pathColor: 0x6688AA,
        ambient: 0.6,
        hasWater: false
    }
};

let boat = null; // For ocean biome

// === THREE.JS SETUP ===
let scene, camera, renderer;
let duck, trail = [];
let trailProgress = 0;
let currentJourneyMinutes = 5; // Track current journey length for world sizing

// Camera orbit controls
let camRadius = 20; // Larger orbit sphere
let camTheta = 0; // horizontal angle
let camPhi = Math.PI / 3; // Lower on horizon (was PI/4)
let isDragging = false;
let lastTouchX = 0;
let lastTouchY = 0;
let lastPinchDist = 0;

// Cinematic auto-camera system
let autoCameraEnabled = true;
let autoCamTime = 0;
let autoCamMode = 'follow'; // 'follow', 'wide', 'sweep', 'dramatic'
let autoCamModeTimer = 0;
let autoCamTargetTheta = 0;
let autoCamTargetPhi = Math.PI / 3;
let autoCamTargetRadius = 20;

// Duck base position (without bounce animation)
let duckBasePos = new THREE.Vector3();

// === GROUND TEXTURE GENERATOR ===
function createGroundTexture(biome) {
    const texCanvas = document.createElement('canvas');
    texCanvas.width = 256;
    texCanvas.height = 256;
    const ctx = texCanvas.getContext('2d');
    const config = BIOME_CONFIG[biome];
    
    // Base gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, config.groundColors[0]);
    gradient.addColorStop(0.5, config.groundColors[1]);
    gradient.addColorStop(1, config.groundColors[2]);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 256, 256);
    
    if (biome === 'forest') {
        // Grass blades
        for (let i = 0; i < 3000; i++) {
            const x = Math.random() * 256;
            const y = Math.random() * 256;
            const length = 8 + Math.random() * 15;
            const angle = -Math.PI/2 + (Math.random() - 0.5) * 0.6;
            const greenBase = 100 + Math.random() * 80;
            ctx.strokeStyle = `rgb(${40 + Math.random() * 40}, ${greenBase}, ${30 + Math.random() * 30})`;
            ctx.lineWidth = 1 + Math.random();
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
            ctx.stroke();
        }
        // Flowers
        for (let i = 0; i < 100; i++) {
            const colors = ['#fff', '#ffff99', '#ffccff', '#ccffcc'];
            ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
            ctx.beginPath();
            ctx.arc(Math.random() * 256, Math.random() * 256, 1 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (biome === 'desert') {
        // Sand texture with ripples - more brown/tan, less yellow
        for (let i = 0; i < 2000; i++) {
            const x = Math.random() * 256;
            const y = Math.random() * 256;
            // Shifted to brown/tan range (less green/yellow, more red)
            const r = 160 + Math.random() * 50;
            const g = 120 + Math.random() * 40;
            const b = 80 + Math.random() * 30;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            ctx.beginPath();
            ctx.ellipse(x, y, 3 + Math.random() * 5, 1 + Math.random() * 2, Math.random() * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
        // Darker cracks and shadows
        for (let i = 0; i < 40; i++) {
            ctx.strokeStyle = `rgba(100, 70, 45, 0.35)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            let x = Math.random() * 256, y = Math.random() * 256;
            ctx.moveTo(x, y);
            for (let j = 0; j < 5; j++) {
                x += (Math.random() - 0.5) * 20;
                y += (Math.random() - 0.5) * 20;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        // Add some darker rock patches for contrast
        for (let i = 0; i < 25; i++) {
            ctx.fillStyle = `rgba(90, 65, 45, 0.25)`;
            ctx.beginPath();
            ctx.ellipse(Math.random() * 256, Math.random() * 256, 8 + Math.random() * 12, 4 + Math.random() * 8, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (biome === 'ocean') {
        // Waves pattern
        for (let y = 0; y < 256; y += 8) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + Math.random() * 0.15})`;
            ctx.lineWidth = 2 + Math.random() * 3;
            ctx.beginPath();
            for (let x = 0; x < 256; x += 5) {
                const wave = Math.sin((x + y * 0.3) * 0.1) * 3;
                if (x === 0) ctx.moveTo(x, y + wave);
                else ctx.lineTo(x, y + wave);
            }
            ctx.stroke();
        }
        // Sparkles
        for (let i = 0; i < 50; i++) {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`;
            ctx.beginPath();
            ctx.arc(Math.random() * 256, Math.random() * 256, 1 + Math.random(), 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (biome === 'winter') {
        // Rocky, icy tundra texture
        // Base rocky texture
        for (let i = 0; i < 1200; i++) {
            const gray = 100 + Math.random() * 60;
            const blue = gray + Math.random() * 20;
            ctx.fillStyle = `rgb(${gray - 10}, ${gray}, ${blue})`;
            ctx.beginPath();
            ctx.arc(Math.random() * 256, Math.random() * 256, 1 + Math.random() * 4, 0, Math.PI * 2);
            ctx.fill();
        }
        // Blue ice patches
        for (let i = 0; i < 40; i++) {
            const alpha = 0.3 + Math.random() * 0.3;
            ctx.fillStyle = `rgba(100, 160, 200, ${alpha})`;
            ctx.beginPath();
            ctx.ellipse(Math.random() * 256, Math.random() * 256, 8 + Math.random() * 20, 5 + Math.random() * 12, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        }
        // Snow patches (less bright)
        for (let i = 0; i < 30; i++) {
            ctx.fillStyle = `rgba(200, 210, 220, ${0.4 + Math.random() * 0.3})`;
            ctx.beginPath();
            ctx.ellipse(Math.random() * 256, Math.random() * 256, 6 + Math.random() * 12, 4 + Math.random() * 8, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        }
        // Dark rock cracks
        for (let i = 0; i < 25; i++) {
            ctx.strokeStyle = `rgba(60, 70, 80, 0.4)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            let x = Math.random() * 256, y = Math.random() * 256;
            ctx.moveTo(x, y);
            for (let j = 0; j < 4; j++) {
                x += (Math.random() - 0.5) * 25;
                y += (Math.random() - 0.5) * 25;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
    }
    
    const texture = new THREE.CanvasTexture(texCanvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(30, 40);
    return texture;
}

// === BOAT FOR OCEAN BIOME ===
function buildBoat() {
    boat = new THREE.Group();
    
    const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const woodLightMat = new THREE.MeshStandardMaterial({ color: 0xA0522D });
    
    // Hull (bottom)
    const hull = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 0.4, 3.5),
        woodMat
    );
    hull.position.y = -0.1;
    boat.add(hull);
    
    // Sides
    const sideL = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.6, 3.5),
        woodLightMat
    );
    sideL.position.set(-1.15, 0.2, 0);
    boat.add(sideL);
    
    const sideR = sideL.clone();
    sideR.position.x = 1.15;
    boat.add(sideR);
    
    // Front (pointy)
    const front = new THREE.Mesh(
        new THREE.BoxGeometry(2.3, 0.6, 0.3),
        woodLightMat
    );
    front.position.set(0, 0.2, 1.6);
    boat.add(front);
    
    // Back
    const back = new THREE.Mesh(
        new THREE.BoxGeometry(2.3, 0.6, 0.3),
        woodLightMat
    );
    back.position.set(0, 0.2, -1.6);
    boat.add(back);
    
    // Seat
    const seat = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.15, 0.6),
        woodMat
    );
    seat.position.set(0, 0.35, -0.5);
    boat.add(seat);
    
    // Oars
    const oarMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    
    const oarL = new THREE.Group();
    const oarHandleL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 2.5), oarMat);
    oarHandleL.position.z = 1;
    oarL.add(oarHandleL);
    const oarPaddleL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.8), oarMat);
    oarPaddleL.position.z = 2.5;
    oarL.add(oarPaddleL);
    oarL.position.set(-1.3, 0.3, 0);
    oarL.rotation.x = -0.3;
    boat.add(oarL);
    boat.oarL = oarL;
    
    const oarR = new THREE.Group();
    const oarHandleR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 2.5), oarMat);
    oarHandleR.position.z = 1;
    oarR.add(oarHandleR);
    const oarPaddleR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.8), oarMat);
    oarPaddleR.position.z = 2.5;
    oarR.add(oarPaddleR);
    oarR.position.set(1.3, 0.3, 0);
    oarR.rotation.x = -0.3;
    boat.add(oarR);
    boat.oarR = oarR;
    
    boat.position.copy(duck.position);
    boat.position.y = 0.3;
    scene.add(boat);
}

function initThree() {
    const container = document.getElementById('canvas-container');
    const biome = BIOME_CONFIG[selectedBiome];
    
    scene = new THREE.Scene();
    
    // Sky gradient via fog - based on biome
    scene.background = new THREE.Color(biome.skyColor);
    scene.fog = new THREE.Fog(biome.fogColor, 50, 150);
    
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 15);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);
    
    // Lighting - adjusted per biome
    const ambient = new THREE.AmbientLight(0xffffff, biome.ambient);
    scene.add(ambient);
    
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 1024;
    sun.shadow.mapSize.height = 1024;
    scene.add(sun);
    
    // Generate biome-specific ground texture
    const groundTexture = createGroundTexture(selectedBiome);
    
    // Terrain with height variation (flat for ocean)
    const groundGeo = new THREE.PlaneGeometry(200, 300, 100, 150);
    const positions = groundGeo.attributes.position;
    
    // Simple noise function for hills
    function noise(x, z) {
        if (selectedBiome === 'ocean') return 0; // Flat ocean
        const scale = selectedBiome === 'desert' ? 0.5 : 1; // Lower desert dunes
        return (Math.sin(x * 0.1) * Math.cos(z * 0.08) * 2 +
               Math.sin(x * 0.05 + z * 0.05) * 3 +
               Math.sin(x * 0.2) * Math.cos(z * 0.15) * 0.5) * scale;
    }
    
    for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        
        const distFromPath = Math.abs(x);
        const pathFlatness = Math.max(0, 1 - distFromPath / 12);
        const height = noise(x, y) * (1 - pathFlatness);
        
        positions.setZ(i, height);
    }
    
    groundGeo.computeVertexNormals();
    positions.needsUpdate = true;
    
    const groundMat = new THREE.MeshStandardMaterial({ 
        map: groundTexture,
        roughness: selectedBiome === 'ocean' ? 0.3 : 0.9,
        metalness: selectedBiome === 'ocean' ? 0.1 : 0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Water features (ponds) - only for forest
    if (selectedBiome === 'forest') {
        const waterMat = new THREE.MeshStandardMaterial({ 
            color: 0x4A90D9, 
            transparent: true, 
            opacity: 0.7,
            roughness: 0.2,
            metalness: 0.1
        });
        const pondPositions = [[-25, -30], [30, -70], [-28, -100]];
        pondPositions.forEach(([px, pz]) => {
            const pond = new THREE.Mesh(
                new THREE.CircleGeometry(5 + Math.random() * 3, 16),
                waterMat
            );
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(px, 0.1, pz);
            scene.add(pond);
        });
    }
    
    // Build trail
    buildTrail();
    
    // Build duck (with boat for ocean)
    buildDuck();
    if (selectedBiome === 'ocean') {
        buildBoat();
    }
    
    // Biome-specific scenery
    buildScenery();
    
    // Background ducks (not in ocean - they'd need boats too!)
    if (selectedBiome !== 'ocean') {
        addBackgroundDucks();
    }
    
    // Handle resize
    window.addEventListener('resize', onResize);
    
    // Orbit camera touch controls
    renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
    renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
    renderer.domElement.addEventListener('touchend', onTouchEnd);
    
    // Mouse controls for desktop
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
    
    animate();
}

function onTouchStart(e) {
    e.preventDefault();
    // Disable auto camera on user interaction
    if (autoCameraEnabled) {
        autoCameraEnabled = false;
        console.log('üì∑ Manual camera control');
    }
    
    if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        // Pinch start
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDist = Math.sqrt(dx * dx + dy * dy);
    }
}

function onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
        const deltaX = e.touches[0].clientX - lastTouchX;
        const deltaY = e.touches[0].clientY - lastTouchY;
        
        camTheta -= deltaX * 0.01;
        camPhi -= deltaY * 0.01;
        
        // Clamp phi to avoid flipping
        camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi));
        
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        // Pinch zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const pinchDist = Math.sqrt(dx * dx + dy * dy);
        
        const delta = lastPinchDist - pinchDist;
        camRadius += delta * 0.05;
        camRadius = Math.max(5, Math.min(50, camRadius));
        
        lastPinchDist = pinchDist;
    }
}

function onTouchEnd(e) {
    if (e.touches.length === 0) {
        isDragging = false;
    }
}

function onMouseDown(e) {
    // Disable auto camera on user interaction
    if (autoCameraEnabled) {
        autoCameraEnabled = false;
        console.log('üì∑ Manual camera control');
    }
    
    isDragging = true;
    lastTouchX = e.clientX;
    lastTouchY = e.clientY;
}

function onMouseMove(e) {
    if (!isDragging) return;
    
    const deltaX = e.clientX - lastTouchX;
    const deltaY = e.clientY - lastTouchY;
    
    camTheta -= deltaX * 0.01;
    camPhi -= deltaY * 0.01;
    camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi));
    
    lastTouchX = e.clientX;
    lastTouchY = e.clientY;
}

function onMouseUp() {
    isDragging = false;
}

function onWheel(e) {
    e.preventDefault();
    camRadius += e.deltaY * 0.02;
    camRadius = Math.max(5, Math.min(50, camRadius));
}

// Rebuild ground sized for journey duration
function rebuildGround(minutes = 5) {
    // Remove existing ground
    scene.children = scene.children.filter(c => !c.userData.isGround && !c.userData.isPond);
    
    const trailLength = minutes * 60;
    const groundDepth = Math.max(300, trailLength + 100); // Trail length + buffer
    const groundWidth = 200;
    
    // Adjust fog for longer journeys
    const biome = BIOME_CONFIG[selectedBiome];
    const fogNear = Math.min(50, groundDepth * 0.15);
    const fogFar = Math.max(150, groundDepth * 0.6);
    scene.fog = new THREE.Fog(biome.fogColor, fogNear, fogFar);
    
    // Create larger ground
    const groundTexture = createGroundTexture(selectedBiome);
    const segmentsX = 100;
    const segmentsY = Math.ceil(150 * (groundDepth / 300)); // Scale segments with size
    const groundGeo = new THREE.PlaneGeometry(groundWidth, groundDepth, segmentsX, segmentsY);
    const positions = groundGeo.attributes.position;
    
    function noise(x, z) {
        if (selectedBiome === 'ocean') return 0;
        const scale = selectedBiome === 'desert' ? 0.5 : 1;
        return (Math.sin(x * 0.1) * Math.cos(z * 0.08) * 2 +
               Math.sin(x * 0.05 + z * 0.05) * 3 +
               Math.sin(x * 0.2) * Math.cos(z * 0.15) * 0.5) * scale;
    }
    
    for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const distFromPath = Math.abs(x);
        const pathFlatness = Math.max(0, 1 - distFromPath / 12);
        positions.setZ(i, noise(x, y) * (1 - pathFlatness));
    }
    groundGeo.computeVertexNormals();
    
    const groundMat = new THREE.MeshStandardMaterial({ 
        map: groundTexture,
        roughness: selectedBiome === 'ocean' ? 0.3 : 0.9,
        metalness: selectedBiome === 'ocean' ? 0.1 : 0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -(groundDepth / 2 - 150); // Offset to extend behind start
    ground.receiveShadow = true;
    ground.userData.isGround = true;
    scene.add(ground);
    
    // Rebuild ponds for forest (distributed along journey)
    if (selectedBiome === 'forest') {
        const waterMat = new THREE.MeshStandardMaterial({ 
            color: 0x4A90D9, transparent: true, opacity: 0.7, roughness: 0.2 
        });
        const numPonds = Math.ceil(minutes / 3); // More ponds for longer journeys
        for (let i = 0; i < numPonds; i++) {
            const pz = -30 - (i * trailLength / numPonds);
            const px = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 15);
            const pond = new THREE.Mesh(
                new THREE.CircleGeometry(5 + Math.random() * 3, 16),
                waterMat
            );
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(px, 0.1, pz);
            pond.userData.isPond = true;
            scene.add(pond);
        }
    }
}

// Terrain height function (must match ground generation)
// Plane rotated -90¬∞ around X: world Z = -local Y, so use -z to sample noise
function getTerrainHeight(x, z) {
    const localY = -z; // Convert world Z back to plane local Y
    const distFromPath = Math.abs(x);
    const pathFlatness = Math.max(0, 1 - distFromPath / 12);
    // Use same noise formula as terrain mesh displacement
    const noiseVal = Math.sin(x * 0.1) * Math.cos(localY * 0.08) * 2 +
                     Math.sin(x * 0.05 + localY * 0.05) * 3 +
                     Math.sin(x * 0.2) * Math.cos(localY * 0.15) * 0.5;
    return noiseVal * (1 - pathFlatness);
}

function buildTrail(minutes = 5) {
    // Clear old trail stones
    scene.children = scene.children.filter(c => !c.userData.isTrailElement);
    
    // Trail length scales with time - longer trail = duck covers more ground
    const trailLength = minutes * 60; // 3x longer than original
    const numPoints = Math.max(10, minutes * 5);
    
    // Create a winding path
    const pathPoints = [];
    for (let i = 0; i <= numPoints; i++) {
        const t = i / numPoints;
        const x = Math.sin(t * Math.PI * 2 * (minutes / 5)) * 8;
        const z = -t * trailLength + 20;
        // Ocean is flat, others have terrain
        const y = selectedBiome === 'ocean' ? 0.5 : getTerrainHeight(x, z) + 0.15;
        pathPoints.push(new THREE.Vector3(x, y, z));
    }
    trail = pathPoints;
    
    // Biome-specific path markers
    const biome = BIOME_CONFIG[selectedBiome];
    
    if (selectedBiome === 'ocean') {
        // Ocean: small buoys marking the path (fewer)
        pathPoints.filter((_, i) => i % 3 === 0).forEach((point, i) => {
            const buoy = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.6, 0.4),
                new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xFF6600 : 0xFFFFFF })
            );
            buoy.position.copy(point);
            buoy.position.y = 0.3;
            buoy.userData.isTrailElement = true;
            scene.add(buoy);
        });
    } else if (selectedBiome === 'winter') {
        // Winter: ice path markers
        const iceMat = new THREE.MeshStandardMaterial({ 
            color: 0xADD8E6, 
            transparent: true, 
            opacity: 0.8,
            roughness: 0.1
        });
        pathPoints.forEach((point) => {
            const ice = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), iceMat);
            ice.position.copy(point);
            ice.position.y = point.y - 0.1;
            ice.rotation.y = Math.random() * 0.3;
            ice.receiveShadow = true;
            ice.userData.isTrailElement = true;
            scene.add(ice);
        });
    } else if (selectedBiome === 'desert') {
        // Desert: flat sandstone path
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0xC4A574, roughness: 0.9 });
        pathPoints.forEach((point) => {
            const stone = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), stoneMat);
            stone.position.copy(point);
            stone.rotation.y = Math.random() * 0.3;
            stone.receiveShadow = true;
            stone.castShadow = true;
            stone.userData.isTrailElement = true;
            scene.add(stone);
        });
    } else {
        // Forest: stepping stones
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0xD4A574, roughness: 0.8 });
        pathPoints.forEach((point) => {
            const stone = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.3, 1.5), stoneMat);
            stone.position.copy(point);
            stone.rotation.y = Math.random() * 0.3;
            stone.receiveShadow = true;
            stone.castShadow = true;
            stone.userData.isTrailElement = true;
            scene.add(stone);
        });
    }
    
    // Start marker (flag)
    const startY = trail[0].y;
    const flagPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 3),
        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
    );
    flagPole.position.set(trail[0].x, startY + 1.5, trail[0].z);
    flagPole.userData.isTrailElement = true;
    scene.add(flagPole);
    
    const flag = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.7, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x4CAF50 })
    );
    flag.position.set(trail[0].x + 0.5, startY + 2.5, trail[0].z);
    flag.userData.isTrailElement = true;
    scene.add(flag);
    
    // Finish marker
    const endY = trail[trail.length-1].y;
    const finishPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 3),
        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
    );
    finishPole.position.set(trail[trail.length-1].x, endY + 1.5, trail[trail.length-1].z);
    finishPole.userData.isTrailElement = true;
    scene.add(finishPole);
    
    const finishFlag = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.7, 0.1),
        new THREE.MeshStandardMaterial({ color: 0xFF6B35 })
    );
    finishFlag.position.set(trail[trail.length-1].x + 0.5, endY + 2.5, trail[trail.length-1].z);
    finishFlag.userData.isTrailElement = true;
    scene.add(finishFlag);
}

// All available duck types for random selection
const DUCK_TYPES = ['classic', 'chef', 'farmer', 'construction', 'police', 'firefighter', 
                    'doctor', 'sailor', 'pirate', 'cowboy', 'wizard', 'ninja', 'astronaut'];

// Randomly selected duck type for this session
let selectedDuckType = DUCK_TYPES[Math.floor(Math.random() * DUCK_TYPES.length)];

function buildDuck() {
    duck = new THREE.Group();
    
    // Ninja has dark body, astronaut has white
    let bodyColor = 0xFFD93D; // Default yellow
    if (selectedDuckType === 'ninja') bodyColor = 0x333333;
    else if (selectedDuckType === 'astronaut') bodyColor = 0xFFFFFF;
    
    const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
    const beakMat = new THREE.MeshStandardMaterial({ color: 0xFF8C00 });
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    
    // Body (blocky)
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 1, 1.4),
        bodyMat
    );
    body.position.y = 0.8;
    body.castShadow = true;
    duck.add(body);
    
    // Head
    const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.9, 0.9),
        bodyMat
    );
    head.position.set(0, 1.7, 0.3);
    head.castShadow = true;
    duck.add(head);
    
    // Beak
    const beak = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.5),
        beakMat
    );
    beak.position.set(0, 1.55, 0.9);
    duck.add(beak);
    
    // Eyes (open)
    const eyeL = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 0.1),
        eyeMat
    );
    eyeL.position.set(-0.25, 1.8, 0.75);
    duck.add(eyeL);
    duck.eyeL = eyeL;
    
    const eyeR = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 0.1),
        eyeMat
    );
    eyeR.position.set(0.25, 1.8, 0.75);
    duck.add(eyeR);
    duck.eyeR = eyeR;
    
    // Eyes (closed - for sleeping)
    const eyeClosedL = new THREE.Mesh(
        new THREE.BoxGeometry(0.22, 0.05, 0.1),
        eyeMat
    );
    eyeClosedL.position.set(-0.25, 1.75, 0.76);
    eyeClosedL.visible = false;
    duck.add(eyeClosedL);
    duck.eyeClosedL = eyeClosedL;
    
    const eyeClosedR = new THREE.Mesh(
        new THREE.BoxGeometry(0.22, 0.05, 0.1),
        eyeMat
    );
    eyeClosedR.position.set(0.25, 1.75, 0.76);
    eyeClosedR.visible = false;
    duck.add(eyeClosedR);
    duck.eyeClosedR = eyeClosedR;
    
    // Zzz bubbles for sleeping
    const zzzGroup = new THREE.Group();
    const zMat = new THREE.MeshBasicMaterial({ color: 0xCCCCFF });
    const z1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.1), zMat);
    z1.position.set(0, 0, 0);
    zzzGroup.add(z1);
    const z2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), zMat);
    z2.position.set(0.25, 0.3, 0);
    zzzGroup.add(z2);
    const z3 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.1), zMat);
    z3.position.set(0.45, 0.55, 0);
    zzzGroup.add(z3);
    zzzGroup.position.set(0.4, 2.1, 0.6);
    zzzGroup.visible = false;
    duck.add(zzzGroup);
    duck.zzz = zzzGroup;
    
    // Wings
    const wingL = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.6, 0.8),
        bodyMat
    );
    wingL.position.set(-0.7, 0.9, 0);
    duck.add(wingL);
    duck.wingL = wingL;
    
    const wingR = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.6, 0.8),
        bodyMat
    );
    wingR.position.set(0.7, 0.9, 0);
    duck.add(wingR);
    duck.wingR = wingR;
    
    // Feet
    const footL = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.15, 0.6),
        beakMat
    );
    footL.position.set(-0.3, 0.1, 0.1);
    duck.add(footL);
    duck.footL = footL;
    
    const footR = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.15, 0.6),
        beakMat
    );
    footR.position.set(0.3, 0.1, 0.1);
    duck.add(footR);
    duck.footR = footR;
    
    // === ADD COSTUME BASED ON TYPE ===
    addDuckCostume(duck, selectedDuckType);
    
    // Position at start (raised above terrain, or in boat for ocean)
    duck.position.copy(trail[0]);
    if (selectedBiome === 'ocean') {
        duck.position.y = 0.9; // In the boat
    } else {
        duck.position.y = getTerrainHeight(trail[0].x, trail[0].z) + 0.5;
    }
    duckBasePos.copy(duck.position);
    
    scene.add(duck);
    
    // Log which duck was selected
    console.log('ü¶Ü Your buddy today:', selectedDuckType, 'in', selectedBiome);
}

function addDuckCostume(duckGroup, type) {
    if (type === 'classic') return; // No accessories
    
    switch (type) {
        case 'chef': {
            // Chef hat
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 0.7, 0.7),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            hat.position.set(0, 2.35, 0.25);
            hat.castShadow = true;
            duckGroup.add(hat);
            break;
        }
        case 'farmer': {
            // Straw hat
            const hatBrim = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.15, 1.2),
                new THREE.MeshStandardMaterial({ color: 0xC4A574 })
            );
            hatBrim.position.set(0, 2.2, 0.25);
            duckGroup.add(hatBrim);
            const hatTop = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.3, 0.6),
                new THREE.MeshStandardMaterial({ color: 0xC4A574 })
            );
            hatTop.position.set(0, 2.4, 0.25);
            duckGroup.add(hatTop);
            break;
        }
        case 'construction': {
            // Hard hat
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.85, 0.35, 0.85),
                new THREE.MeshStandardMaterial({ color: 0xFFD700 })
            );
            hat.position.set(0, 2.25, 0.25);
            hat.castShadow = true;
            duckGroup.add(hat);
            // Safety vest
            const vest = new THREE.Mesh(
                new THREE.BoxGeometry(1.25, 0.5, 0.8),
                new THREE.MeshStandardMaterial({ color: 0xFF6600 })
            );
            vest.position.set(0, 1.0, 0.05);
            duckGroup.add(vest);
            break;
        }
        case 'police': {
            // Police cap
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.75, 0.3, 0.75),
                new THREE.MeshStandardMaterial({ color: 0x1E3A5F })
            );
            hat.position.set(0, 2.25, 0.25);
            duckGroup.add(hat);
            // Badge
            const badge = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.08),
                new THREE.MeshStandardMaterial({ color: 0xFFD700 })
            );
            badge.position.set(0.3, 0.9, 0.72);
            duckGroup.add(badge);
            break;
        }
        case 'firefighter': {
            // Fire helmet
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.85, 0.4, 0.85),
                new THREE.MeshStandardMaterial({ color: 0xCC0000 })
            );
            hat.position.set(0, 2.3, 0.25);
            hat.castShadow = true;
            duckGroup.add(hat);
            // Yellow coat
            const coat = new THREE.Mesh(
                new THREE.BoxGeometry(1.25, 0.7, 0.9),
                new THREE.MeshStandardMaterial({ color: 0xFFCC00 })
            );
            coat.position.set(0, 0.75, 0.05);
            duckGroup.add(coat);
            break;
        }
        case 'doctor': {
            // Scrubs (light blue, covers front and sides)
            const scrubs = new THREE.Mesh(
                new THREE.BoxGeometry(1.3, 0.85, 1.0),
                new THREE.MeshStandardMaterial({ color: 0x87CEEB })
            );
            scrubs.position.set(0, 0.7, 0.1);
            duckGroup.add(scrubs);
            // White coat over scrubs
            const coat = new THREE.Mesh(
                new THREE.BoxGeometry(1.35, 0.9, 0.4),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            coat.position.set(0, 0.65, -0.25);
            duckGroup.add(coat);
            // Stethoscope tubing (around neck)
            const stethTube = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.5, 0.08),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            stethTube.position.set(0.25, 1.1, 0.55);
            duckGroup.add(stethTube);
            const stethTube2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.5, 0.08),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            stethTube2.position.set(-0.25, 1.1, 0.55);
            duckGroup.add(stethTube2);
            // Stethoscope chest piece
            const stethChest = new THREE.Mesh(
                new THREE.BoxGeometry(0.25, 0.25, 0.1),
                new THREE.MeshStandardMaterial({ color: 0xC0C0C0 })
            );
            stethChest.position.set(0, 0.7, 0.75);
            duckGroup.add(stethChest);
            // Head mirror
            const mirror = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.3, 0.08),
                new THREE.MeshStandardMaterial({ color: 0xCCCCCC })
            );
            mirror.position.set(0, 2.15, 0.65);
            duckGroup.add(mirror);
            break;
        }
        case 'sailor': {
            // Sailor cap
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 0.2, 0.7),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            hat.position.set(0, 2.2, 0.25);
            duckGroup.add(hat);
            // Blue ribbon
            const ribbon = new THREE.Mesh(
                new THREE.BoxGeometry(0.75, 0.12, 0.15),
                new THREE.MeshStandardMaterial({ color: 0x1E3A5F })
            );
            ribbon.position.set(0, 2.1, 0.5);
            duckGroup.add(ribbon);
            break;
        }
        case 'pirate': {
            // Pirate hat
            const hat = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 0.35, 0.6),
                new THREE.MeshStandardMaterial({ color: 0x2F1810 })
            );
            hat.position.set(0, 2.25, 0.25);
            duckGroup.add(hat);
            // Eye patch
            const eyepatch = new THREE.Mesh(
                new THREE.BoxGeometry(0.25, 0.2, 0.12),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            eyepatch.position.set(-0.25, 1.8, 0.77);
            duckGroup.add(eyepatch);
            break;
        }
        case 'cowboy': {
            // Cowboy hat
            const hatBrim = new THREE.Mesh(
                new THREE.BoxGeometry(1.4, 0.12, 1.4),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            hatBrim.position.set(0, 2.2, 0.25);
            duckGroup.add(hatBrim);
            const hatTop = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.45, 0.6),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            hatTop.position.set(0, 2.5, 0.25);
            duckGroup.add(hatTop);
            break;
        }
        case 'wizard': {
            // Purple robe
            const robe = new THREE.Mesh(
                new THREE.BoxGeometry(1.25, 0.75, 0.9),
                new THREE.MeshStandardMaterial({ color: 0x4B0082 })
            );
            robe.position.set(0, 0.7, 0.05);
            duckGroup.add(robe);
            // Wizard hat (cone)
            const hat = new THREE.Mesh(
                new THREE.ConeGeometry(0.45, 0.9, 4),
                new THREE.MeshStandardMaterial({ color: 0x4B0082 })
            );
            hat.position.set(0, 2.55, 0.25);
            hat.castShadow = true;
            duckGroup.add(hat);
            // Star on hat
            const star = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.15, 0.08),
                new THREE.MeshStandardMaterial({ color: 0xFFD700 })
            );
            star.position.set(0, 2.3, 0.6);
            duckGroup.add(star);
            break;
        }
        case 'ninja': {
            // Ninja mask (covers lower face)
            const mask = new THREE.Mesh(
                new THREE.BoxGeometry(0.95, 0.4, 0.95),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            mask.position.set(0, 1.5, 0.3);
            duckGroup.add(mask);
            // Red headband
            const headband = new THREE.Mesh(
                new THREE.BoxGeometry(1.0, 0.15, 0.4),
                new THREE.MeshStandardMaterial({ color: 0xCC0000 })
            );
            headband.position.set(0, 2.0, 0.5);
            duckGroup.add(headband);
            break;
        }
        case 'astronaut': {
            // Space suit body (slightly bigger)
            const suit = new THREE.Mesh(
                new THREE.BoxGeometry(1.35, 1.1, 1.0),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            suit.position.set(0, 0.75, 0.05);
            duckGroup.add(suit);
            // Helmet (transparent blue-ish)
            const helmet = new THREE.Mesh(
                new THREE.BoxGeometry(1.05, 1.05, 1.05),
                new THREE.MeshStandardMaterial({ 
                    color: 0x87CEEB, 
                    transparent: true, 
                    opacity: 0.4 
                })
            );
            helmet.position.set(0, 1.7, 0.3);
            duckGroup.add(helmet);
            // Visor (dark)
            const visor = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 0.35, 0.15),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            visor.position.set(0, 1.75, 0.8);
            duckGroup.add(visor);
            break;
        }
    }
}

let animals = [];
let grassBlades = [];

function buildScenery() {
    animals = [];
    grassBlades = [];
    
    // Call biome-specific scenery builder
    switch (selectedBiome) {
        case 'forest': buildForestScenery(); break;
        case 'desert': buildDesertScenery(); break;
        case 'ocean': buildOceanScenery(); break;
        case 'winter': buildWinterScenery(); break;
    }
}

// Get scene depth based on current journey - use this for scenery distribution
function getSceneDepth() {
    return Math.max(200, currentJourneyMinutes * 60);
}

// Scale number of scenery items based on journey length
function getSceneryCount(baseCount) {
    const scale = Math.max(1, currentJourneyMinutes / 5);
    return Math.ceil(baseCount * scale);
}

// === FOREST BIOME ===
function buildForestScenery() {
    const depth = getSceneDepth();
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x2D5A27 });
    const treeMat2 = new THREE.MeshStandardMaterial({ color: 0x3D6B37 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x707070, roughness: 0.9 });
    
    // LOTS of pine trees (dense forest!)
    for (let i = 0; i < getSceneryCount(120); i++) {
        const x = (Math.random() - 0.5) * 90;
        const z = Math.random() * -depth + 40;
        if (Math.abs(x) < 10) continue;
        
        const terrainY = getTerrainHeight(x, z);
        const scale = 0.5 + Math.random() * 1.0;
        const treeGroup = new THREE.Group();
        
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2 * scale, 0.35 * scale, 2.5 * scale, 8),
            trunkMat
        );
        trunk.position.y = 1.25 * scale;
        trunk.castShadow = true;
        treeGroup.add(trunk);
        
        const foliageMat = Math.random() > 0.5 ? treeMat : treeMat2;
        for (let j = 0; j < 3; j++) {
            const layerSize = (1.8 - j * 0.4) * scale;
            const foliage = new THREE.Mesh(
                new THREE.ConeGeometry(layerSize, (1.5 - j * 0.2) * scale, 8),
                foliageMat
            );
            foliage.position.y = (2.5 + j * 0.9) * scale;
            foliage.castShadow = true;
            treeGroup.add(foliage);
        }
        
        treeGroup.position.set(x, terrainY, z);
        scene.add(treeGroup);
    }
    
    // Grass clumps
    const grassMat = new THREE.MeshLambertMaterial({ color: 0x5a8f2a, side: THREE.DoubleSide });
    for (let i = 0; i < getSceneryCount(200); i++) {
        const x = (Math.random() - 0.5) * 60;
        const z = Math.random() * -depth + 30;
        const terrainY = getTerrainHeight(x, z);
        const grassGroup = new THREE.Group();
        for (let j = 0; j < 4; j++) {
            const height = 0.5 + Math.random() * 0.6;
            const blade = new THREE.Mesh(new THREE.PlaneGeometry(0.1, height), grassMat);
            blade.position.set((Math.random() - 0.5) * 0.6, height / 2, (Math.random() - 0.5) * 0.6);
            blade.rotation.y = Math.random() * Math.PI;
            grassGroup.add(blade);
        }
        grassGroup.position.set(x, terrainY, z);
        grassGroup.userData.swayOffset = Math.random() * Math.PI * 2;
        scene.add(grassGroup);
        grassBlades.push(grassGroup);
    }
    
    // Flowers, mushrooms, bushes
    const flowerColors = [0xFF69B4, 0xFF6B6B, 0xFFD93D, 0xAA96DA, 0xFFFFFF];
    for (let i = 0; i < getSceneryCount(80); i++) {
        const x = (Math.random() - 0.5) * 50;
        const z = Math.random() * -(depth * 0.75) + 30;
        const terrainY = getTerrainHeight(x, z);
        const flower = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.4, 0.3),
            new THREE.MeshStandardMaterial({ color: flowerColors[Math.floor(Math.random() * flowerColors.length)] })
        );
        flower.position.set(x, terrainY + 0.2, z);
        scene.add(flower);
    }
    
    // Mushrooms
    for (let i = 0; i < getSceneryCount(20); i++) {
        const x = (Math.random() - 0.5) * 40;
        const z = Math.random() * -(depth * 0.5) + 20;
        const terrainY = getTerrainHeight(x, z);
        const stem = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), new THREE.MeshStandardMaterial({ color: 0xFFF5E6 }));
        stem.position.set(x, terrainY + 0.15, z);
        scene.add(stem);
        const cap = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0xFF6B6B }));
        cap.position.set(x, terrainY + 0.4, z);
        scene.add(cap);
    }
    
    // Animals: Rabbits, Squirrels, Birds, Deer
    addForestAnimals();
}

function addForestAnimals() {
    const depth = getSceneDepth();
    
    // Rabbits
    for (let i = 0; i < getSceneryCount(6); i++) {
        const rabbit = createRabbit();
        const rx = (Math.random() - 0.5) * 40;
        const rz = Math.random() * -(depth * 0.4) + 15;
        rabbit.position.set(rx, getTerrainHeight(rx, rz), rz);
        rabbit.rotation.y = Math.random() * Math.PI * 2;
        rabbit.userData.baseY = rabbit.position.y;
        scene.add(rabbit);
        animals.push({ mesh: rabbit, type: 'rabbit', hopTime: Math.random() * 100 });
    }
    
    // Squirrels
    for (let i = 0; i < getSceneryCount(5); i++) {
        const squirrel = createSquirrel();
        const sx = (Math.random() > 0.5 ? 1 : -1) * (15 + Math.random() * 15);
        const sz = Math.random() * -(depth * 0.4) + 15;
        squirrel.position.set(sx, getTerrainHeight(sx, sz), sz);
        squirrel.rotation.y = Math.random() * Math.PI * 2;
        squirrel.userData.baseY = squirrel.position.y;
        scene.add(squirrel);
        animals.push({ mesh: squirrel, type: 'squirrel', wiggleTime: Math.random() * 100 });
    }
    
    // Birds
    for (let i = 0; i < getSceneryCount(8); i++) {
        const bird = createBird(0x4A90D9);
        const bx = (Math.random() - 0.5) * 50;
        const bz = Math.random() * -(depth * 0.5) + 20;
        const inAir = Math.random() > 0.4;
        bird.position.set(bx, inAir ? 5 + Math.random() * 8 : getTerrainHeight(bx, bz) + 0.3, bz);
        bird.rotation.y = Math.random() * Math.PI * 2;
        bird.userData.baseY = bird.position.y;
        scene.add(bird);
        animals.push({ mesh: bird, type: 'bird', flying: inAir, flapTime: Math.random() * 100 });
    }
    
    // Deer
    for (let i = 0; i < getSceneryCount(3); i++) {
        const deer = createDeer();
        const dx = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 15);
        const dz = Math.random() * -(depth * 0.5) + 20;
        deer.position.set(dx, getTerrainHeight(dx, dz), dz);
        deer.rotation.y = Math.random() * Math.PI * 2;
        deer.userData.baseY = deer.position.y;
        scene.add(deer);
        animals.push({ mesh: deer, type: 'deer', walkTime: Math.random() * 100 });
    }
}

// === DESERT BIOME ===
function buildDesertScenery() {
    const depth = getSceneDepth();
    const cactusMat = new THREE.MeshStandardMaterial({ color: 0x2D5A27 });
    const rockMat = new THREE.MeshStandardMaterial({ color: 0xA08060, roughness: 0.9 });
    const sandRockMat = new THREE.MeshStandardMaterial({ color: 0xC4A574 });
    
    // Cacti (various types)
    for (let i = 0; i < getSceneryCount(60); i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = Math.random() * -depth + 35;
        if (Math.abs(x) < 8) continue;
        
        const terrainY = getTerrainHeight(x, z);
        const cactus = new THREE.Group();
        const height = 1.5 + Math.random() * 2;
        
        // Main body
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, height, 0.6),
            cactusMat
        );
        body.position.y = height / 2;
        cactus.add(body);
        
        // Arms (sometimes)
        if (Math.random() > 0.4) {
            const armHeight = 0.8 + Math.random() * 0.5;
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.4), cactusMat);
            arm.position.set(0.6, height * 0.5, 0);
            cactus.add(arm);
            const armUp = new THREE.Mesh(new THREE.BoxGeometry(0.4, armHeight, 0.4), cactusMat);
            armUp.position.set(0.9, height * 0.5 + armHeight / 2, 0);
            cactus.add(armUp);
        }
        if (Math.random() > 0.5) {
            const armHeight = 0.6 + Math.random() * 0.4;
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.35, 0.35), cactusMat);
            arm.position.set(-0.55, height * 0.6, 0);
            cactus.add(arm);
            const armUp = new THREE.Mesh(new THREE.BoxGeometry(0.35, armHeight, 0.35), cactusMat);
            armUp.position.set(-0.8, height * 0.6 + armHeight / 2, 0);
            cactus.add(armUp);
        }
        
        cactus.position.set(x, terrainY, z);
        scene.add(cactus);
    }
    
    // Desert rocks/boulders
    for (let i = 0; i < getSceneryCount(40); i++) {
        const x = (Math.random() - 0.5) * 70;
        const z = Math.random() * -(depth * 0.75) + 30;
        const terrainY = getTerrainHeight(x, z);
        const size = 0.5 + Math.random() * 1.5;
        const rock = new THREE.Mesh(
            new THREE.BoxGeometry(size, size * 0.6, size * 0.8),
            Math.random() > 0.5 ? rockMat : sandRockMat
        );
        rock.position.set(x, terrainY + size * 0.3, z);
        rock.rotation.y = Math.random() * Math.PI;
        rock.castShadow = true;
        scene.add(rock);
    }
    
    // Tumbleweeds
    for (let i = 0; i < getSceneryCount(25); i++) {
        const x = (Math.random() - 0.5) * 60;
        const z = Math.random() * -(depth * 0.7) + 25;
        const terrainY = getTerrainHeight(x, z);
        const tumbleweed = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x8B7355, wireframe: false })
        );
        tumbleweed.position.set(x, terrainY + 0.3, z);
        tumbleweed.userData.rollSpeed = 0.5 + Math.random();
        scene.add(tumbleweed);
        grassBlades.push(tumbleweed); // Reuse for animation
    }
    
    // Skulls (spooky desert!)
    for (let i = 0; i < getSceneryCount(8); i++) {
        const x = (Math.random() - 0.5) * 50;
        const z = Math.random() * -(depth * 0.5) + 20;
        const terrainY = getTerrainHeight(x, z);
        const skull = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.35, 0.3),
            new THREE.MeshStandardMaterial({ color: 0xFFF8DC })
        );
        skull.position.set(x, terrainY + 0.15, z);
        skull.rotation.y = Math.random() * Math.PI;
        scene.add(skull);
    }
    
    // Desert animals
    addDesertAnimals();
}

function addDesertAnimals() {
    const depth = getSceneDepth();
    
    // Roadrunners
    for (let i = 0; i < getSceneryCount(4); i++) {
        const roadrunner = createRoadrunner();
        const rx = (Math.random() - 0.5) * 50;
        const rz = Math.random() * -(depth * 0.4) + 15;
        roadrunner.position.set(rx, getTerrainHeight(rx, rz), rz);
        roadrunner.rotation.y = Math.random() * Math.PI * 2;
        roadrunner.userData.baseY = roadrunner.position.y;
        scene.add(roadrunner);
        animals.push({ mesh: roadrunner, type: 'roadrunner', runTime: Math.random() * 100 });
    }
    
    // Scorpions
    for (let i = 0; i < getSceneryCount(6); i++) {
        const scorpion = createScorpion();
        const sx = (Math.random() - 0.5) * 40;
        const sz = Math.random() * -(depth * 0.3) + 10;
        scorpion.position.set(sx, getTerrainHeight(sx, sz), sz);
        scorpion.rotation.y = Math.random() * Math.PI * 2;
        scorpion.userData.baseY = scorpion.position.y;
        scene.add(scorpion);
        animals.push({ mesh: scorpion, type: 'scorpion', scuttleTime: Math.random() * 100 });
    }
    
    // Camels
    for (let i = 0; i < getSceneryCount(3); i++) {
        const camel = createCamel();
        const cx = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 15);
        const cz = Math.random() * -(depth * 0.5) + 20;
        camel.position.set(cx, getTerrainHeight(cx, cz), cz);
        camel.rotation.y = Math.random() * Math.PI * 2;
        camel.userData.baseY = camel.position.y;
        scene.add(camel);
        animals.push({ mesh: camel, type: 'camel', walkTime: Math.random() * 100 });
    }
    
    // Vultures (flying)
    for (let i = 0; i < getSceneryCount(4); i++) {
        const vulture = createBird(0x333333);
        vulture.scale.set(1.5, 1.5, 1.5);
        const vx = (Math.random() - 0.5) * 60;
        const vz = Math.random() * -(depth * 0.4) + 20;
        vulture.position.set(vx, 8 + Math.random() * 10, vz);
        vulture.userData.baseY = vulture.position.y;
        scene.add(vulture);
        animals.push({ mesh: vulture, type: 'bird', flying: true, flapTime: Math.random() * 100 });
    }
}

// === OCEAN BIOME ===
function buildOceanScenery() {
    const depth = getSceneDepth();
    
    // Coral reefs
    const coralColors = [0xFF6B6B, 0xFF69B4, 0xFFD93D, 0x9B59B6, 0x3498DB];
    for (let i = 0; i < getSceneryCount(80); i++) {
        const x = (Math.random() - 0.5) * 70;
        const z = Math.random() * -depth + 30;
        if (Math.abs(x) < 10) continue;
        
        const coral = new THREE.Group();
        const color = coralColors[Math.floor(Math.random() * coralColors.length)];
        const coralMat = new THREE.MeshStandardMaterial({ color });
        
        // Branch coral
        for (let j = 0; j < 3 + Math.floor(Math.random() * 4); j++) {
            const branch = new THREE.Mesh(
                new THREE.BoxGeometry(0.2 + Math.random() * 0.3, 0.5 + Math.random() * 1, 0.2 + Math.random() * 0.3),
                coralMat
            );
            branch.position.set((Math.random() - 0.5) * 0.8, 0.3 + Math.random() * 0.5, (Math.random() - 0.5) * 0.8);
            coral.add(branch);
        }
        
        coral.position.set(x, 0.1, z);
        scene.add(coral);
    }
    
    // Seaweed
    const seaweedMat = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
    for (let i = 0; i < getSceneryCount(150); i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = Math.random() * -depth + 35;
        const seaweedGroup = new THREE.Group();
        
        for (let j = 0; j < 3; j++) {
            const height = 1 + Math.random() * 2;
            const blade = new THREE.Mesh(new THREE.PlaneGeometry(0.3, height), seaweedMat);
            blade.position.set((Math.random() - 0.5) * 0.5, height / 2, (Math.random() - 0.5) * 0.5);
            blade.rotation.y = Math.random() * Math.PI;
            seaweedGroup.add(blade);
        }
        
        seaweedGroup.position.set(x, 0.1, z);
        seaweedGroup.userData.swayOffset = Math.random() * Math.PI * 2;
        scene.add(seaweedGroup);
        grassBlades.push(seaweedGroup);
    }
    
    // Buoys
    for (let i = 0; i < getSceneryCount(10); i++) {
        const x = (Math.random() - 0.5) * 40;
        const z = Math.random() * -(depth * 0.6) + 20;
        const buoy = new THREE.Group();
        
        const base = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 1.2, 0.8),
            new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xFF0000 : 0xFFFFFF })
        );
        base.position.y = 0.6;
        buoy.add(base);
        
        const top = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.5, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        top.position.y = 1.4;
        buoy.add(top);
        
        buoy.position.set(x, 0.2, z);
        buoy.userData.bobOffset = Math.random() * Math.PI * 2;
        scene.add(buoy);
        animals.push({ mesh: buoy, type: 'buoy', bobTime: Math.random() * 100 });
    }
    
    // Ocean animals
    addOceanAnimals();
}

function addOceanAnimals() {
    const depth = getSceneDepth();
    
    // Fish (various colors)
    const fishColors = [0xFF6B6B, 0xFFD93D, 0x3498DB, 0x9B59B6, 0x2ECC71, 0xFF8C00];
    for (let i = 0; i < getSceneryCount(20); i++) {
        const fish = createFish(fishColors[Math.floor(Math.random() * fishColors.length)]);
        const fx = (Math.random() - 0.5) * 60;
        const fz = Math.random() * -(depth * 0.5) + 15;
        fish.position.set(fx, 0.5 + Math.random() * 2, fz);
        fish.rotation.y = Math.random() * Math.PI * 2;
        fish.userData.baseY = fish.position.y;
        fish.userData.swimOffset = Math.random() * Math.PI * 2;
        scene.add(fish);
        animals.push({ mesh: fish, type: 'fish', swimTime: Math.random() * 100 });
    }
    
    // Dolphins
    for (let i = 0; i < getSceneryCount(3); i++) {
        const dolphin = createDolphin();
        const dx = (Math.random() - 0.5) * 50;
        const dz = Math.random() * -(depth * 0.4) + 15;
        dolphin.position.set(dx, 1, dz);
        dolphin.rotation.y = Math.random() * Math.PI * 2;
        dolphin.userData.baseY = 1;
        scene.add(dolphin);
        animals.push({ mesh: dolphin, type: 'dolphin', jumpTime: Math.random() * 100 });
    }
    
    // Seagulls (flying above)
    for (let i = 0; i < getSceneryCount(8); i++) {
        const seagull = createBird(0xFFFFFF);
        const sx = (Math.random() - 0.5) * 70;
        const sz = Math.random() * -(depth * 0.6) + 25;
        seagull.position.set(sx, 6 + Math.random() * 8, sz);
        seagull.userData.baseY = seagull.position.y;
        scene.add(seagull);
        animals.push({ mesh: seagull, type: 'bird', flying: true, flapTime: Math.random() * 100 });
    }
    
    // Sea turtle
    for (let i = 0; i < getSceneryCount(2); i++) {
        const turtle = createSeaTurtle();
        const tx = (Math.random() - 0.5) * 40;
        const tz = Math.random() * -(depth * 0.3) + 10;
        turtle.position.set(tx, 0.8, tz);
        turtle.rotation.y = Math.random() * Math.PI * 2;
        turtle.userData.baseY = 0.8;
        scene.add(turtle);
        animals.push({ mesh: turtle, type: 'turtle', swimTime: Math.random() * 100 });
    }
}

// === WINTER BIOME ===
function buildWinterScenery() {
    const depth = getSceneDepth();
    const frostTreeMat = new THREE.MeshStandardMaterial({ color: 0x6A8A9A }); // Frosted blue-gray
    const frostTreeMat2 = new THREE.MeshStandardMaterial({ color: 0x5A7A8A });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3A3028 }); // Darker trunk
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x556070, roughness: 0.9 });
    const blueIceMat = new THREE.MeshStandardMaterial({ 
        color: 0x4A90B0, 
        transparent: true, 
        opacity: 0.8,
        roughness: 0.1,
        metalness: 0.4
    });
    
    // Frosted pine trees
    for (let i = 0; i < getSceneryCount(80); i++) {
        const x = (Math.random() - 0.5) * 80;
        const z = Math.random() * -depth + 35;
        if (Math.abs(x) < 10) continue;
        
        const terrainY = getTerrainHeight(x, z);
        const scale = 0.5 + Math.random() * 0.9;
        const treeGroup = new THREE.Group();
        
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2 * scale, 0.35 * scale, 2.5 * scale, 8),
            trunkMat
        );
        trunk.position.y = 1.25 * scale;
        trunk.castShadow = true;
        treeGroup.add(trunk);
        
        const foliageMat = Math.random() > 0.5 ? frostTreeMat : frostTreeMat2;
        for (let j = 0; j < 3; j++) {
            const layerSize = (1.8 - j * 0.4) * scale;
            const foliage = new THREE.Mesh(
                new THREE.ConeGeometry(layerSize, (1.5 - j * 0.2) * scale, 8),
                foliageMat
            );
            foliage.position.y = (2.5 + j * 0.9) * scale;
            foliage.castShadow = true;
            treeGroup.add(foliage);
        }
        
        treeGroup.position.set(x, terrainY, z);
        scene.add(treeGroup);
    }
    
    // Rocky outcrops
    for (let i = 0; i < getSceneryCount(35); i++) {
        const x = (Math.random() - 0.5) * 70;
        const z = Math.random() * -(depth * 0.75) + 30;
        const terrainY = getTerrainHeight(x, z);
        const size = 0.8 + Math.random() * 2;
        const rock = new THREE.Mesh(
            new THREE.BoxGeometry(size, size * 0.7, size * 0.9),
            rockMat
        );
        rock.position.set(x, terrainY + size * 0.35, z);
        rock.rotation.y = Math.random() * Math.PI;
        rock.rotation.x = (Math.random() - 0.5) * 0.2;
        rock.castShadow = true;
        scene.add(rock);
    }
    
    // Blue ice formations
    for (let i = 0; i < getSceneryCount(25); i++) {
        const x = (Math.random() - 0.5) * 60;
        const z = Math.random() * -(depth * 0.6) + 25;
        const terrainY = getTerrainHeight(x, z);
        
        const iceGroup = new THREE.Group();
        // Ice spikes
        for (let j = 0; j < 2 + Math.floor(Math.random() * 3); j++) {
            const height = 0.8 + Math.random() * 1.5;
            const spike = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.3, height, 5),
                blueIceMat
            );
            spike.position.set((Math.random() - 0.5) * 0.8, height / 2, (Math.random() - 0.5) * 0.8);
            iceGroup.add(spike);
        }
        iceGroup.position.set(x, terrainY, z);
        scene.add(iceGroup);
    }
    
    // Frozen pools
    const frozenPoolMat = new THREE.MeshStandardMaterial({ 
        color: 0x5A9AB5, 
        transparent: true, 
        opacity: 0.7,
        roughness: 0.05,
        metalness: 0.5
    });
    for (let i = 0; i < getSceneryCount(8); i++) {
        const x = (Math.random() - 0.5) * 50;
        const z = Math.random() * -(depth * 0.5) + 20;
        const pool = new THREE.Mesh(
            new THREE.BoxGeometry(4 + Math.random() * 5, 0.15, 3 + Math.random() * 4),
            frozenPoolMat
        );
        pool.position.set(x, 0.08, z);
        pool.rotation.y = Math.random() * Math.PI;
        scene.add(pool);
    }
    
    // Fewer snowmen (they look out of place in harsh tundra)
    for (let i = 0; i < getSceneryCount(3); i++) {
        const snowman = createSnowman();
        const sx = (Math.random() - 0.5) * 30;
        const sz = Math.random() * -(depth * 0.25) + 10;
        snowman.position.set(sx, getTerrainHeight(sx, sz), sz);
        snowman.rotation.y = Math.random() * Math.PI * 2;
        scene.add(snowman);
    }
    
    // Light snow particles (fewer, smaller)
    for (let i = 0; i < getSceneryCount(60); i++) {
        const snowflake = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.08, 0.08),
            new THREE.MeshBasicMaterial({ color: 0xCCDDEE })
        );
        snowflake.position.set(
            (Math.random() - 0.5) * 100,
            5 + Math.random() * 15,
            Math.random() * -(depth * 0.75) + 30
        );
        snowflake.userData.fallSpeed = 0.015 + Math.random() * 0.02;
        snowflake.userData.drift = (Math.random() - 0.5) * 0.015;
        scene.add(snowflake);
        grassBlades.push(snowflake);
    }
    
    // Winter animals
    addWinterAnimals();
}

function addWinterAnimals() {
    const depth = getSceneDepth();
    
    // Penguins!
    for (let i = 0; i < getSceneryCount(6); i++) {
        const penguin = createPenguin();
        const px = (Math.random() - 0.5) * 35;
        const pz = Math.random() * -(depth * 0.3) + 10;
        penguin.position.set(px, getTerrainHeight(px, pz), pz);
        penguin.rotation.y = Math.random() * Math.PI * 2;
        penguin.userData.baseY = penguin.position.y;
        scene.add(penguin);
        animals.push({ mesh: penguin, type: 'penguin', waddleTime: Math.random() * 100 });
    }
    
    // Polar bear
    for (let i = 0; i < getSceneryCount(2); i++) {
        const bear = createPolarBear();
        const bx = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 15);
        const bz = Math.random() * -(depth * 0.4) + 15;
        bear.position.set(bx, getTerrainHeight(bx, bz), bz);
        bear.rotation.y = Math.random() * Math.PI * 2;
        bear.userData.baseY = bear.position.y;
        scene.add(bear);
        animals.push({ mesh: bear, type: 'bear', walkTime: Math.random() * 100 });
    }
    
    // Snowy owls
    for (let i = 0; i < getSceneryCount(4); i++) {
        const owl = createOwl();
        const ox = (Math.random() - 0.5) * 50;
        const oz = Math.random() * -(depth * 0.4) + 15;
        const inAir = Math.random() > 0.5;
        owl.position.set(ox, inAir ? 5 + Math.random() * 6 : getTerrainHeight(ox, oz) + 0.3, oz);
        owl.userData.baseY = owl.position.y;
        scene.add(owl);
        animals.push({ mesh: owl, type: 'owl', flying: inAir, flapTime: Math.random() * 100 });
    }
    
    // Arctic foxes
    for (let i = 0; i < getSceneryCount(3); i++) {
        const fox = createArcticFox();
        const fx = (Math.random() - 0.5) * 40;
        const fz = Math.random() * -(depth * 0.35) + 15;
        fox.position.set(fx, getTerrainHeight(fx, fz), fz);
        fox.rotation.y = Math.random() * Math.PI * 2;
        fox.userData.baseY = fox.position.y;
        scene.add(fox);
        animals.push({ mesh: fox, type: 'fox', runTime: Math.random() * 100 });
    }
}

// === ANIMAL CREATION HELPERS ===
function createRabbit() {
    const rabbit = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xE8DCC4 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.7), mat);
    body.position.y = 0.3;
    rabbit.add(body);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.4), mat);
    head.position.set(0, 0.45, 0.4);
    rabbit.add(head);
    const earL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.08), mat);
    earL.position.set(-0.12, 0.75, 0.35);
    rabbit.add(earL);
    const earR = earL.clone();
    earR.position.x = 0.12;
    rabbit.add(earR);
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.15), mat);
    tail.position.set(0, 0.35, -0.35);
    rabbit.add(tail);
    return rabbit;
}

function createSquirrel() {
    const squirrel = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xB87333 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.5), mat);
    body.position.y = 0.25;
    squirrel.add(body);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), mat);
    head.position.set(0, 0.35, 0.3);
    squirrel.add(head);
    const tail1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 0.2), mat);
    tail1.position.set(0, 0.35, -0.3);
    squirrel.add(tail1);
    const tail2 = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.3, 0.18), mat);
    tail2.position.set(0, 0.6, -0.35);
    squirrel.add(tail2);
    const tail3 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 0.15), mat);
    tail3.position.set(0, 0.85, -0.3);
    squirrel.add(tail3);
    return squirrel;
}

function createBird(color) {
    const bird = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.35), mat);
    bird.add(body);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.18), mat);
    head.position.set(0, 0.1, 0.2);
    bird.add(head);
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.12), new THREE.MeshStandardMaterial({ color: 0xFFA500 }));
    beak.position.set(0, 0.08, 0.35);
    bird.add(beak);
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.2), mat);
    wingL.position.set(-0.2, 0.05, 0);
    bird.add(wingL);
    bird.wingL = wingL;
    const wingR = wingL.clone();
    wingR.position.x = 0.2;
    bird.add(wingR);
    bird.wingR = wingR;
    return bird;
}

function createDeer() {
    const deer = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xA0522D });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 1.4), mat);
    body.position.y = 1;
    deer.add(body);
    const neck = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 0.3), mat);
    neck.position.set(0, 1.5, 0.5);
    deer.add(neck);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.5), mat);
    head.position.set(0, 1.8, 0.7);
    deer.add(head);
    // Antlers
    const antlerMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const antlerL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.08), antlerMat);
    antlerL.position.set(-0.15, 2.1, 0.6);
    deer.add(antlerL);
    const antlerR = antlerL.clone();
    antlerR.position.x = 0.15;
    deer.add(antlerR);
    // Legs
    for (let i = 0; i < 4; i++) {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), mat);
        leg.position.set((i % 2 === 0 ? -0.25 : 0.25), 0.35, (i < 2 ? 0.5 : -0.5));
        deer.add(leg);
    }
    return deer;
}

function createRoadrunner() {
    const bird = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.6), mat);
    body.position.y = 0.4;
    bird.add(body);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.25), mat);
    head.position.set(0, 0.5, 0.35);
    bird.add(head);
    // Long beak
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.4), new THREE.MeshStandardMaterial({ color: 0xFFA500 }));
    beak.position.set(0, 0.48, 0.65);
    bird.add(beak);
    // Crest
    const crest = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.1), mat);
    crest.position.set(0, 0.65, 0.3);
    bird.add(crest);
    // Legs
    const legMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.25, 0.06), legMat);
    legL.position.set(-0.1, 0.12, 0);
    bird.add(legL);
    const legR = legL.clone();
    legR.position.x = 0.1;
    bird.add(legR);
    // Tail
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 0.4), mat);
    tail.position.set(0, 0.4, -0.4);
    bird.add(tail);
    return bird;
}

function createScorpion() {
    const scorpion = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0x2F1810 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.4), mat);
    body.position.y = 0.1;
    scorpion.add(body);
    // Tail segments
    for (let i = 0; i < 4; i++) {
        const seg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.12), mat);
        seg.position.set(0, 0.1 + i * 0.08, -0.25 - i * 0.1);
        seg.rotation.x = -0.3 * i;
        scorpion.add(seg);
    }
    // Stinger
    const stinger = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.06), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    stinger.position.set(0, 0.45, -0.55);
    scorpion.add(stinger);
    // Claws
    const clawL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.2), mat);
    clawL.position.set(-0.2, 0.1, 0.25);
    scorpion.add(clawL);
    const clawR = clawL.clone();
    clawR.position.x = 0.2;
    scorpion.add(clawR);
    scorpion.scale.set(0.7, 0.7, 0.7);
    return scorpion;
}

function createCamel() {
    const camel = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xC4A574 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1.8), mat);
    body.position.y = 1.4;
    camel.add(body);
    // Hump
    const hump = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.6), mat);
    hump.position.set(0, 2, 0);
    camel.add(hump);
    // Neck
    const neck = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), mat);
    neck.position.set(0, 2, 0.8);
    neck.rotation.x = 0.3;
    camel.add(neck);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.4, 0.6), mat);
    head.position.set(0, 2.5, 1.2);
    camel.add(head);
    // Legs
    for (let i = 0; i < 4; i++) {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), mat);
        leg.position.set((i % 2 === 0 ? -0.3 : 0.3), 0.5, (i < 2 ? 0.6 : -0.6));
        camel.add(leg);
    }
    camel.scale.set(0.6, 0.6, 0.6);
    return camel;
}

function createFish(color) {
    const fish = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.4), mat);
    fish.add(body);
    // Tail
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.15), mat);
    tail.position.set(0, 0, -0.25);
    fish.add(tail);
    fish.tail = tail;
    // Fins
    const finTop = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.1, 0.15), mat);
    finTop.position.set(0, 0.12, 0);
    fish.add(finTop);
    return fish;
}

function createDolphin() {
    const dolphin = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0x708090 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 1.2), mat);
    dolphin.add(body);
    // Nose
    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.4), mat);
    nose.position.set(0, 0, 0.7);
    dolphin.add(nose);
    // Tail
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.3), mat);
    tail.position.set(0, 0, -0.7);
    dolphin.add(tail);
    // Dorsal fin
    const fin = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.3), mat);
    fin.position.set(0, 0.3, 0);
    dolphin.add(fin);
    return dolphin;
}

function createSeaTurtle() {
    const turtle = new THREE.Group();
    const shellMat = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
    const skinMat = new THREE.MeshStandardMaterial({ color: 0x3CB371 });
    // Shell
    const shell = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 1), shellMat);
    shell.position.y = 0.2;
    turtle.add(shell);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.3), skinMat);
    head.position.set(0, 0.15, 0.6);
    turtle.add(head);
    // Flippers
    const flipperL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.3), skinMat);
    flipperL.position.set(-0.55, 0.1, 0.2);
    turtle.add(flipperL);
    turtle.flipperL = flipperL;
    const flipperR = flipperL.clone();
    flipperR.position.x = 0.55;
    turtle.add(flipperR);
    turtle.flipperR = flipperR;
    turtle.scale.set(0.7, 0.7, 0.7);
    return turtle;
}

function createSnowman() {
    const snowman = new THREE.Group();
    const snowMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    // Bottom
    const bottom = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1), snowMat);
    bottom.position.y = 0.4;
    snowman.add(bottom);
    // Middle
    const middle = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.7), snowMat);
    middle.position.y = 1;
    snowman.add(middle);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), snowMat);
    head.position.y = 1.5;
    snowman.add(head);
    // Carrot nose
    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0xFF6600 }));
    nose.position.set(0, 1.5, 0.35);
    snowman.add(nose);
    // Eyes
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
    eyeL.position.set(-0.12, 1.6, 0.25);
    snowman.add(eyeL);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.12;
    snowman.add(eyeR);
    // Hat
    const hatBrim = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.08, 0.6), eyeMat);
    hatBrim.position.y = 1.78;
    snowman.add(hatBrim);
    const hatTop = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), eyeMat);
    hatTop.position.y = 2;
    snowman.add(hatTop);
    return snowman;
}

function createPenguin() {
    const penguin = new THREE.Group();
    const blackMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    const orangeMat = new THREE.MeshStandardMaterial({ color: 0xFF6600 });
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.35), blackMat);
    body.position.y = 0.5;
    penguin.add(body);
    // Belly
    const belly = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.1), whiteMat);
    belly.position.set(0, 0.5, 0.18);
    penguin.add(belly);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.3), blackMat);
    head.position.y = 0.95;
    penguin.add(head);
    // Eyes
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), whiteMat);
    eyeL.position.set(-0.1, 1, 0.15);
    penguin.add(eyeL);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.1;
    penguin.add(eyeR);
    // Beak
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.15), orangeMat);
    beak.position.set(0, 0.9, 0.2);
    penguin.add(beak);
    // Feet
    const footL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.05, 0.2), orangeMat);
    footL.position.set(-0.1, 0.025, 0.05);
    penguin.add(footL);
    const footR = footL.clone();
    footR.position.x = 0.1;
    penguin.add(footR);
    // Wings/flippers
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.35, 0.15), blackMat);
    wingL.position.set(-0.25, 0.5, 0);
    penguin.add(wingL);
    penguin.wingL = wingL;
    const wingR = wingL.clone();
    wingR.position.x = 0.25;
    penguin.add(wingR);
    penguin.wingR = wingR;
    return penguin;
}

function createPolarBear() {
    const bear = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 0.7, 1.4), mat);
    body.position.y = 0.8;
    bear.add(body);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.45, 0.6), mat);
    head.position.set(0, 1.1, 0.8);
    bear.add(head);
    // Nose
    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.12, 0.15), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    nose.position.set(0, 1.05, 1.1);
    bear.add(nose);
    // Ears
    const earL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), mat);
    earL.position.set(-0.2, 1.35, 0.7);
    bear.add(earL);
    const earR = earL.clone();
    earR.position.x = 0.2;
    bear.add(earR);
    // Legs
    for (let i = 0; i < 4; i++) {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.5, 0.25), mat);
        leg.position.set((i % 2 === 0 ? -0.3 : 0.3), 0.25, (i < 2 ? 0.4 : -0.4));
        bear.add(leg);
    }
    bear.scale.set(0.7, 0.7, 0.7);
    return bear;
}

function createOwl() {
    const owl = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD });
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.4, 0.3), mat);
    body.position.y = 0.3;
    owl.add(body);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.35), mat);
    head.position.y = 0.65;
    owl.add(head);
    // Eyes (big!)
    const eyeWhiteL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.05), new THREE.MeshStandardMaterial({ color: 0xFFFF00 }));
    eyeWhiteL.position.set(-0.1, 0.7, 0.18);
    owl.add(eyeWhiteL);
    const eyeWhiteR = eyeWhiteL.clone();
    eyeWhiteR.position.x = 0.1;
    owl.add(eyeWhiteR);
    const pupilL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.02), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    pupilL.position.set(-0.1, 0.7, 0.21);
    owl.add(pupilL);
    const pupilR = pupilL.clone();
    pupilR.position.x = 0.1;
    owl.add(pupilR);
    // Beak
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.1), new THREE.MeshStandardMaterial({ color: 0xFFA500 }));
    beak.position.set(0, 0.6, 0.2);
    owl.add(beak);
    // Wings
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.15), darkMat);
    wingL.position.set(-0.28, 0.35, 0);
    owl.add(wingL);
    owl.wingL = wingL;
    const wingR = wingL.clone();
    wingR.position.x = 0.28;
    owl.add(wingR);
    owl.wingR = wingR;
    return owl;
}

function createArcticFox() {
    const fox = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xF8F8FF });
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.6), mat);
    body.position.y = 0.35;
    fox.add(body);
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.22, 0.3), mat);
    head.position.set(0, 0.45, 0.4);
    fox.add(head);
    // Snout
    const snout = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.15), mat);
    snout.position.set(0, 0.4, 0.6);
    fox.add(snout);
    // Nose
    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.05), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    nose.position.set(0, 0.42, 0.68);
    fox.add(nose);
    // Ears
    const earL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.06), mat);
    earL.position.set(-0.08, 0.62, 0.35);
    fox.add(earL);
    const earR = earL.clone();
    earR.position.x = 0.08;
    fox.add(earR);
    // Fluffy tail
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.4), mat);
    tail.position.set(0, 0.35, -0.45);
    fox.add(tail);
    // Legs
    for (let i = 0; i < 4; i++) {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), mat);
        leg.position.set((i % 2 === 0 ? -0.12 : 0.12), 0.1, (i < 2 ? 0.2 : -0.2));
        fox.add(leg);
    }
    fox.scale.set(0.8, 0.8, 0.8);
    return fox;
}

// === BACKGROUND DUCKS ===
let backgroundDucks = [];

function createDuckType(type) {
    const duckGroup = new THREE.Group();
    
    // Base colors
    const yellowMat = new THREE.MeshStandardMaterial({ color: 0xFFD93D });
    const orangeMat = new THREE.MeshStandardMaterial({ color: 0xFF8C00 });
    const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    
    // Type-specific colors
    const colors = {
        classic: { body: 0xFFD93D },
        chef: { body: 0xFFD93D, hat: 0xFFFFFF },
        farmer: { body: 0xFFD93D, hat: 0xC4A574, overalls: 0x4169E1 },
        construction: { body: 0xFFD93D, hat: 0xFFD700, vest: 0xFF6600 },
        police: { body: 0xFFD93D, hat: 0x1E3A5F, uniform: 0x1E3A5F },
        firefighter: { body: 0xFFD93D, hat: 0xCC0000, coat: 0xFFCC00 },
        doctor: { body: 0xFFD93D, coat: 0xFFFFFF },
        sailor: { body: 0xFFD93D, hat: 0xFFFFFF, stripe: 0x1E3A5F },
        pirate: { body: 0xFFD93D, hat: 0x2F1810, eyepatch: 0x111111 },
        cowboy: { body: 0xFFD93D, hat: 0x8B4513 },
        wizard: { body: 0xFFD93D, robe: 0x4B0082, hat: 0x4B0082 },
        ninja: { body: 0x333333, mask: 0x222222 },
        astronaut: { body: 0xFFFFFF, helmet: 0x87CEEB, visor: 0x333333 }
    };
    
    const c = colors[type] || colors.classic;
    const bodyMat = new THREE.MeshStandardMaterial({ color: c.body });
    
    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 1.0), bodyMat);
    body.position.y = 0.55;
    duckGroup.add(body);
    
    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), bodyMat);
    head.position.set(0, 1.15, 0.2);
    duckGroup.add(head);
    
    // Beak
    const beak = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.35), orangeMat);
    beak.position.set(0, 1.05, 0.6);
    duckGroup.add(beak);
    
    // Eyes
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), blackMat);
    eyeL.position.set(-0.18, 1.22, 0.5);
    duckGroup.add(eyeL);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.18;
    duckGroup.add(eyeR);
    
    // Wings
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.4, 0.5), bodyMat);
    wingL.position.set(-0.45, 0.6, 0);
    duckGroup.add(wingL);
    duckGroup.wingL = wingL;
    const wingR = wingL.clone();
    wingR.position.x = 0.45;
    duckGroup.add(wingR);
    duckGroup.wingR = wingR;
    
    // Feet
    const footL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.08, 0.35), orangeMat);
    footL.position.set(-0.2, 0.04, 0.05);
    duckGroup.add(footL);
    duckGroup.footL = footL;
    const footR = footL.clone();
    footR.position.x = 0.2;
    duckGroup.add(footR);
    duckGroup.footR = footR;
    
    // Type-specific accessories
    if (type === 'chef') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.6, 0.15);
        duckGroup.add(hat);
    } else if (type === 'farmer') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.8), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.5, 0.15);
        duckGroup.add(hat);
        const hatTop = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), new THREE.MeshStandardMaterial({ color: c.hat }));
        hatTop.position.set(0, 1.62, 0.15);
        duckGroup.add(hatTop);
    } else if (type === 'construction') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.2, 0.55), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.5, 0.15);
        duckGroup.add(hat);
        const vest = new THREE.Mesh(new THREE.BoxGeometry(0.82, 0.35, 0.5), new THREE.MeshStandardMaterial({ color: c.vest }));
        vest.position.set(0, 0.75, 0.1);
        duckGroup.add(vest);
    } else if (type === 'police') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.5, 0.15);
        duckGroup.add(hat);
        const badge = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.05), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        badge.position.set(0.2, 0.7, 0.52);
        duckGroup.add(badge);
    } else if (type === 'firefighter') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.25, 0.55), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.52, 0.15);
        duckGroup.add(hat);
        const coat = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.5, 0.6), new THREE.MeshStandardMaterial({ color: c.coat }));
        coat.position.set(0, 0.55, 0.05);
        duckGroup.add(coat);
    } else if (type === 'doctor') {
        // Scrubs (light blue)
        const scrubs = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.6, 0.7), new THREE.MeshStandardMaterial({ color: 0x87CEEB }));
        scrubs.position.set(0, 0.5, 0.08);
        duckGroup.add(scrubs);
        // White coat
        const coat = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.65, 0.3), new THREE.MeshStandardMaterial({ color: c.coat }));
        coat.position.set(0, 0.48, -0.15);
        duckGroup.add(coat);
        // Stethoscope
        const stethTube = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        stethTube.position.set(0.15, 0.8, 0.4);
        duckGroup.add(stethTube);
        const stethTube2 = stethTube.clone();
        stethTube2.position.x = -0.15;
        duckGroup.add(stethTube2);
        const stethChest = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.08), new THREE.MeshStandardMaterial({ color: 0xC0C0C0 }));
        stethChest.position.set(0, 0.5, 0.55);
        duckGroup.add(stethChest);
        // Head mirror
        const mirror = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.05), new THREE.MeshStandardMaterial({ color: 0xCCCCCC }));
        mirror.position.set(0, 1.45, 0.45);
        duckGroup.add(mirror);
    } else if (type === 'sailor') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.15, 0.45), whiteMat);
        hat.position.set(0, 1.48, 0.15);
        duckGroup.add(hat);
        const ribbon = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.1), new THREE.MeshStandardMaterial({ color: c.stripe }));
        ribbon.position.set(0, 1.42, 0.3);
        duckGroup.add(ribbon);
    } else if (type === 'pirate') {
        const hat = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.25, 0.4), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.52, 0.15);
        duckGroup.add(hat);
        const eyepatch = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.12, 0.06), blackMat);
        eyepatch.position.set(-0.18, 1.22, 0.52);
        duckGroup.add(eyepatch);
    } else if (type === 'cowboy') {
        const hatBrim = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.9), new THREE.MeshStandardMaterial({ color: c.hat }));
        hatBrim.position.set(0, 1.48, 0.15);
        duckGroup.add(hatBrim);
        const hatTop = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.4), new THREE.MeshStandardMaterial({ color: c.hat }));
        hatTop.position.set(0, 1.65, 0.15);
        duckGroup.add(hatTop);
    } else if (type === 'wizard') {
        const robe = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.55, 0.6), new THREE.MeshStandardMaterial({ color: c.robe }));
        robe.position.set(0, 0.5, 0.05);
        duckGroup.add(robe);
        const hat = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 4), new THREE.MeshStandardMaterial({ color: c.hat }));
        hat.position.set(0, 1.7, 0.15);
        duckGroup.add(hat);
        const star = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        star.position.set(0, 1.55, 0.4);
        duckGroup.add(star);
    } else if (type === 'ninja') {
        const mask = new THREE.Mesh(new THREE.BoxGeometry(0.62, 0.3, 0.62), new THREE.MeshStandardMaterial({ color: c.mask }));
        mask.position.set(0, 1.0, 0.2);
        duckGroup.add(mask);
        const headband = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0xCC0000 }));
        headband.position.set(0, 1.3, 0.35);
        duckGroup.add(headband);
    } else if (type === 'astronaut') {
        const suit = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.75, 0.7), whiteMat);
        suit.position.set(0, 0.55, 0.05);
        duckGroup.add(suit);
        const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshStandardMaterial({ color: c.helmet, transparent: true, opacity: 0.5 }));
        helmet.position.set(0, 1.15, 0.2);
        duckGroup.add(helmet);
        const visor = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.25, 0.1), new THREE.MeshStandardMaterial({ color: c.visor }));
        visor.position.set(0, 1.2, 0.55);
        duckGroup.add(visor);
    }
    
    duckGroup.scale.set(0.7, 0.7, 0.7); // Smaller than main duck
    return duckGroup;
}

function addBackgroundDucks() {
    const duckTypes = ['chef', 'farmer', 'construction', 'police', 'firefighter', 
                       'doctor', 'sailor', 'pirate', 'cowboy', 'wizard', 'ninja', 'astronaut'];
    
    duckTypes.forEach((type, i) => {
        const bgDuck = createDuckType(type);
        
        // Position them along the sides of the trail
        const side = i % 2 === 0 ? -1 : 1;
        const x = side * (18 + Math.random() * 10);
        const z = -20 - i * 12 + Math.random() * 5;
        const terrainY = getTerrainHeight(x, z);
        
        bgDuck.position.set(x, terrainY + 0.2, z);
        bgDuck.rotation.y = side * Math.PI / 4; // Face slightly toward path
        
        bgDuck.userData = {
            type: type,
            walkPhase: Math.random() * Math.PI * 2,
            baseY: terrainY + 0.2,
            startX: x,
            walkDir: side
        };
        
        scene.add(bgDuck);
        backgroundDucks.push(bgDuck);
    });
}

// === ANIMATION ===
let animTime = 0;
let danceTime = 0;
let blinkTimer = 0;
let isBlinking = false;
let isDancing = false;

function animate() {
    requestAnimationFrame(animate);
    
    animTime += 0.05;
    
    if (duck) {
        if (isDancing) {
            // Dance animation
            danceTime += 0.15;
            duck.position.y = Math.abs(Math.sin(danceTime)) * 0.5;
            duck.rotation.y = Math.sin(danceTime * 0.5) * 0.5;
            duck.wingL.rotation.z = Math.sin(danceTime * 2) * 0.5;
            duck.wingR.rotation.z = -Math.sin(danceTime * 2) * 0.5;
        } else if (state === 'journey') {
            // Smooth position update based on elapsed time
            const elapsed = (Date.now() - journeyStartTime - pausedTime) / 1000;
            trailProgress = Math.min(elapsed / totalSeconds, 1);
            
            const idx = Math.floor(trailProgress * (trail.length - 1));
            const nextIdx = Math.min(idx + 1, trail.length - 1);
            const t = (trailProgress * (trail.length - 1)) % 1;
            
            // Smooth interpolation
            const targetX = trail[idx].x + (trail[nextIdx].x - trail[idx].x) * t;
            const targetZ = trail[idx].z + (trail[nextIdx].z - trail[idx].z) * t;
            
            // Target Y based on where we're heading
            const targetTerrainY = selectedBiome === 'ocean' ? 0 : getTerrainHeight(targetX, targetZ);
            const targetY = selectedBiome === 'ocean' ? 0.9 : targetTerrainY + 0.5;
            
            // Update base position (for camera to follow - no bounce)
            duckBasePos.x += (targetX - duckBasePos.x) * 0.1;
            duckBasePos.z += (targetZ - duckBasePos.z) * 0.1;
            
            // Y position smoothly follows target
            duckBasePos.y += (targetY - duckBasePos.y) * 0.15;
            
            // Get terrain height at duck's NEW position and ensure we don't clip through hills
            const currentTerrainY = selectedBiome === 'ocean' ? 0 : getTerrainHeight(duckBasePos.x, duckBasePos.z);
            const minY = selectedBiome === 'ocean' ? 0.9 : currentTerrainY + 0.5;
            duckBasePos.y = Math.max(duckBasePos.y, minY);
            
            // Duck follows base position
            duck.position.x = duckBasePos.x;
            duck.position.z = duckBasePos.z;
            duck.position.y = duckBasePos.y;
            
            // Face direction of travel
            if (nextIdx > idx) {
                const targetAngle = Math.atan2(
                    trail[nextIdx].x - trail[idx].x,
                    trail[nextIdx].z - trail[idx].z
                );
                duck.rotation.y += (targetAngle - duck.rotation.y) * 0.1;
            }
            
            // Blinking logic
            blinkTimer += 0.05;
            if (!isBlinking && blinkTimer > 3 + Math.random() * 2) {
                isBlinking = true;
                blinkTimer = 0;
                setTimeout(() => { isBlinking = false; }, 150);
            }
            
            // Eyes (with blinking)
            duck.eyeL.visible = !isBlinking;
            duck.eyeR.visible = !isBlinking;
            duck.eyeClosedL.visible = isBlinking;
            duck.eyeClosedR.visible = isBlinking;
            duck.zzz.visible = false;
            duck.scale.y = 1;
            
            // Walking animation (bounce added on top of base position)
            duck.wingL.rotation.z = Math.sin(animTime * 2) * 0.2;
            duck.wingR.rotation.z = -Math.sin(animTime * 2) * 0.2;
            duck.footL.position.z = 0.1 + Math.sin(animTime * 3) * 0.1;
            duck.footR.position.z = 0.1 - Math.sin(animTime * 3) * 0.1;
            
            // Celebrate every minute! (quack + visual)
            const elapsedMinutes = Math.floor((totalSeconds - remainingSeconds) / 60);
            if (elapsedMinutes > lastQuackMinute && elapsedMinutes > 0) {
                lastQuackMinute = elapsedMinutes;
                playQuack();
                celebrateMinute();
            }
            
            // Ocean biome: move boat with duck, add wave bobbing
            if (selectedBiome === 'ocean' && boat) {
                boat.position.x = duckBasePos.x;
                boat.position.z = duckBasePos.z;
                boat.position.y = 0.3 + Math.sin(animTime * 1.5) * 0.15; // Wave bobbing
                boat.rotation.x = Math.sin(animTime * 1.2) * 0.05; // Pitch
                boat.rotation.z = Math.sin(animTime * 0.8) * 0.03; // Roll
                boat.rotation.y = duck.rotation.y;
                
                // Rowing animation
                if (boat.oarL && boat.oarR) {
                    boat.oarL.rotation.x = -0.3 + Math.sin(animTime * 2) * 0.4;
                    boat.oarR.rotation.x = -0.3 - Math.sin(animTime * 2) * 0.4;
                }
                
                // Duck sits higher in boat
                duck.position.y = boat.position.y + 0.6;
            } else {
                // Small bounce on top of base position (land biomes)
                const walkBounce = Math.sin(animTime * 3) * 0.1;
                duck.position.y += walkBounce;
            }
        } else if (state === 'paused') {
            // Sleeping animation
            duck.eyeL.visible = false;
            duck.eyeR.visible = false;
            duck.eyeClosedL.visible = true;
            duck.eyeClosedR.visible = true;
            duck.zzz.visible = true;
            
            // Gentle breathing
            const breathe = Math.sin(animTime * 0.8) * 0.03;
            duck.position.y = duckBasePos.y + breathe;
            duck.scale.y = 1 + Math.sin(animTime * 0.8) * 0.02;
            
            // Zzz float up animation
            duck.zzz.position.y = 2.1 + Math.sin(animTime * 0.5) * 0.2;
            duck.zzz.rotation.z = Math.sin(animTime * 0.3) * 0.1;
            
            // Smooth pan to close-up front shot
            camTheta += (autoCamTargetTheta - camTheta) * 0.03;
            camPhi += (autoCamTargetPhi - camPhi) * 0.03;
            camRadius += (autoCamTargetRadius - camRadius) * 0.03;
        } else if (state === 'startled') {
            // Gently startled - duck wakes up surprised
            startledTime += 0.08;
            
            // Eyes open (surprised but not shocked)
            duck.eyeL.visible = true;
            duck.eyeR.visible = true;
            duck.eyeClosedL.visible = false;
            duck.eyeClosedR.visible = false;
            duck.zzz.visible = false;
            
            // Small hop that fades out completely by end of animation (~1.2s = startledTime ~9.6)
            const fadeOut = Math.max(0, 1 - startledTime / 8);
            const hopHeight = Math.sin(startledTime * 2.5) * 0.25 * fadeOut;
            
            // Ease back down to base position
            duck.position.y = duckBasePos.y + Math.abs(hopHeight);
            
            // Gentle head shake that settles
            duck.rotation.z = Math.sin(startledTime * 8) * 0.05 * fadeOut;
            
            // Wings settle back down
            duck.wingL.rotation.z = Math.sin(startledTime * 6) * 0.2 * fadeOut;
            duck.wingR.rotation.z = -Math.sin(startledTime * 6) * 0.2 * fadeOut;
            
            // Camera pulls back smoothly
            const targetRadius = 15 + startledTime * 0.3;
            const targetPhi = Math.PI / 3;
            camPhi += (targetPhi - camPhi) * 0.02;
            camRadius += (targetRadius - camRadius) * 0.02;
            camTheta += (duck.rotation.y + Math.PI - camTheta) * 0.01;
        } else {
            // Idle animation (awake with blinking)
            blinkTimer += 0.05;
            if (!isBlinking && blinkTimer > 3 + Math.random() * 2) {
                isBlinking = true;
                blinkTimer = 0;
                setTimeout(() => { isBlinking = false; }, 150);
            }
            
            duck.eyeL.visible = !isBlinking;
            duck.eyeR.visible = !isBlinking;
            duck.eyeClosedL.visible = isBlinking;
            duck.eyeClosedR.visible = isBlinking;
            duck.zzz.visible = false;
            duck.scale.y = 1;
            duck.position.y = duckBasePos.y + Math.sin(animTime * 0.5) * 0.05;
        }
        
        // === CINEMATIC AUTO-CAMERA SYSTEM ===
        if (autoCameraEnabled && state === 'journey') {
            autoCamTime += 0.016; // ~60fps
            autoCamModeTimer += 0.016;
            
            // Switch camera modes periodically
            if (autoCamModeTimer > 8 + Math.random() * 6) {
                autoCamModeTimer = 0;
                const modes = ['follow', 'wide', 'sweep', 'dramatic', 'side'];
                autoCamMode = modes[Math.floor(Math.random() * modes.length)];
                
                switch (autoCamMode) {
                    case 'follow':
                        // Close following shot
                        autoCamTargetRadius = 12 + Math.random() * 5;
                        autoCamTargetPhi = Math.PI / 3 + (Math.random() - 0.5) * 0.3;
                        break;
                    case 'wide':
                        // Cinematic wide shot - pull way back
                        autoCamTargetRadius = 35 + Math.random() * 15;
                        autoCamTargetPhi = Math.PI / 4; // Higher angle
                        break;
                    case 'sweep':
                        // Sweeping pan around subject
                        autoCamTargetRadius = 18 + Math.random() * 8;
                        autoCamTargetPhi = Math.PI / 3;
                        break;
                    case 'dramatic':
                        // Low dramatic angle
                        autoCamTargetRadius = 10 + Math.random() * 5;
                        autoCamTargetPhi = Math.PI / 2.2; // Very low
                        break;
                    case 'side':
                        // Side tracking shot
                        autoCamTargetRadius = 15 + Math.random() * 5;
                        autoCamTargetPhi = Math.PI / 2.8;
                        autoCamTargetTheta = camTheta + Math.PI / 2; // Jump to side
                        break;
                }
            }
            
            // Smooth camera movement based on mode
            if (autoCamMode === 'sweep') {
                // Continuous slow pan
                autoCamTargetTheta += 0.003;
            } else {
                // Gentle drift
                autoCamTargetTheta += Math.sin(autoCamTime * 0.3) * 0.001;
            }
            
            // Smoothly interpolate camera parameters
            camTheta += (autoCamTargetTheta - camTheta) * 0.02;
            camPhi += (autoCamTargetPhi - camPhi) * 0.02;
            camRadius += (autoCamTargetRadius - camRadius) * 0.02;
        }
        
        // Camera orbits around duck - focus on head when sleeping
        const headOffset = (state === 'paused' || state === 'startled') ? 1.5 : 0.1;
        const orbitCenter = new THREE.Vector3(
            duckBasePos.x,
            duckBasePos.y + headOffset, // Higher when sleeping to focus on head
            duckBasePos.z
        );
        
        let targetX = orbitCenter.x + camRadius * Math.sin(camTheta) * Math.sin(camPhi);
        let targetY = orbitCenter.y + camRadius * Math.cos(camPhi);
        let targetZ = orbitCenter.z + camRadius * Math.cos(camTheta) * Math.sin(camPhi);
        
        // Prevent camera from going below terrain (ocean is flat at 0)
        const terrainAtCam = selectedBiome === 'ocean' ? 0 : getTerrainHeight(targetX, targetZ);
        const minCamHeight = terrainAtCam + 1.5; // Stay at least 1.5 units above terrain
        if (targetY < minCamHeight) {
            targetY = minCamHeight;
        }
        
        camera.position.x += (targetX - camera.position.x) * 0.1;
        camera.position.y += (targetY - camera.position.y) * 0.1;
        camera.position.z += (targetZ - camera.position.z) * 0.1;
        camera.lookAt(orbitCenter);
    }
    
    // Animate background ducks
    backgroundDucks.forEach(bgDuck => {
        bgDuck.userData.walkPhase += 0.03;
        const phase = bgDuck.userData.walkPhase;
        
        // Walking animation
        if (bgDuck.wingL) {
            bgDuck.wingL.rotation.z = Math.sin(phase * 2) * 0.15;
            bgDuck.wingR.rotation.z = -Math.sin(phase * 2) * 0.15;
        }
        if (bgDuck.footL) {
            bgDuck.footL.position.z = 0.05 + Math.sin(phase * 3) * 0.08;
            bgDuck.footR.position.z = 0.05 - Math.sin(phase * 3) * 0.08;
        }
        
        // Small bounce
        bgDuck.position.y = bgDuck.userData.baseY + Math.sin(phase * 3) * 0.03;
        
        // Wander slightly
        const wander = Math.sin(phase * 0.2) * 2;
        bgDuck.position.x = bgDuck.userData.startX + wander * bgDuck.userData.walkDir;
    });
    
    // Sway grass/seaweed OR animate snow/tumbleweeds
    grassBlades.forEach(grass => {
        if (selectedBiome === 'winter' && grass.userData.fallSpeed) {
            // Falling snow
            grass.position.y -= grass.userData.fallSpeed;
            grass.position.x += grass.userData.drift;
            grass.rotation.x += 0.02;
            grass.rotation.z += 0.01;
            
            // Reset when hits ground
            if (grass.position.y < 0) {
                grass.position.y = 15 + Math.random() * 5;
                grass.position.x = (Math.random() - 0.5) * 100;
            }
        } else if (selectedBiome === 'desert' && grass.userData.rollSpeed) {
            // Rolling tumbleweeds
            grass.rotation.x += grass.userData.rollSpeed * 0.05;
            grass.rotation.z += grass.userData.rollSpeed * 0.03;
        } else {
            // Normal grass/seaweed sway
            const swayOffset = grass.userData.swayOffset || 0;
            const sway = Math.sin(animTime * 1.5 + swayOffset) * 0.1;
            grass.rotation.x = sway;
            grass.rotation.z = sway * 0.5;
        }
    });
    
    // Animate animals
    animals.forEach(animal => {
        const baseY = animal.mesh.userData.baseY || 0;
        
        if (animal.type === 'rabbit') {
            animal.hopTime += 0.05;
            animal.mesh.position.y = baseY + Math.abs(Math.sin(animal.hopTime * 0.5)) * 0.15;
            if (animal.mesh.children[2]) {
                animal.mesh.children[2].rotation.z = Math.sin(animal.hopTime * 2) * 0.1;
                animal.mesh.children[3].rotation.z = -Math.sin(animal.hopTime * 2) * 0.1;
            }
        } else if (animal.type === 'squirrel') {
            animal.wiggleTime += 0.08;
            animal.mesh.position.y = baseY + Math.sin(animal.wiggleTime) * 0.03;
        } else if (animal.type === 'bird' || animal.type === 'owl') {
            animal.flapTime += 0.1;
            if (animal.flying) {
                if (animal.mesh.wingL) {
                    animal.mesh.wingL.rotation.z = Math.sin(animal.flapTime * 3) * 0.5;
                    animal.mesh.wingR.rotation.z = -Math.sin(animal.flapTime * 3) * 0.5;
                }
                animal.mesh.position.y = baseY + Math.sin(animal.flapTime) * 0.3;
            } else {
                animal.mesh.rotation.x = Math.sin(animal.flapTime * 0.5) * 0.1;
            }
        } else if (animal.type === 'deer' || animal.type === 'camel' || animal.type === 'bear') {
            animal.walkTime += 0.03;
            animal.mesh.position.y = baseY + Math.sin(animal.walkTime) * 0.02;
        } else if (animal.type === 'penguin') {
            animal.waddleTime += 0.08;
            animal.mesh.rotation.z = Math.sin(animal.waddleTime) * 0.1; // Waddle!
            animal.mesh.position.y = baseY + Math.abs(Math.sin(animal.waddleTime * 2)) * 0.05;
            if (animal.mesh.wingL) {
                animal.mesh.wingL.rotation.z = Math.sin(animal.waddleTime) * 0.2;
                animal.mesh.wingR.rotation.z = -Math.sin(animal.waddleTime) * 0.2;
            }
        } else if (animal.type === 'fox') {
            animal.runTime += 0.06;
            animal.mesh.position.y = baseY + Math.abs(Math.sin(animal.runTime)) * 0.08;
        } else if (animal.type === 'roadrunner') {
            animal.runTime += 0.1;
            animal.mesh.position.y = baseY + Math.abs(Math.sin(animal.runTime * 2)) * 0.1;
        } else if (animal.type === 'scorpion') {
            animal.scuttleTime += 0.05;
            animal.mesh.position.y = baseY + Math.sin(animal.scuttleTime * 4) * 0.01;
        } else if (animal.type === 'fish') {
            animal.swimTime += 0.08;
            const swimOffset = animal.mesh.userData.swimOffset || 0;
            animal.mesh.position.y = baseY + Math.sin(animal.swimTime + swimOffset) * 0.3;
            animal.mesh.position.x += Math.sin(animal.swimTime * 0.5) * 0.01;
            if (animal.mesh.tail) {
                animal.mesh.tail.rotation.y = Math.sin(animal.swimTime * 3) * 0.3;
            }
        } else if (animal.type === 'dolphin') {
            animal.jumpTime += 0.03;
            // Occasional jumps out of water
            const jumpCycle = Math.sin(animal.jumpTime * 0.5);
            if (jumpCycle > 0.8) {
                animal.mesh.position.y = baseY + (jumpCycle - 0.8) * 10;
                animal.mesh.rotation.x = -0.3;
            } else {
                animal.mesh.position.y = baseY + Math.sin(animal.jumpTime) * 0.2;
                animal.mesh.rotation.x = Math.sin(animal.jumpTime) * 0.1;
            }
        } else if (animal.type === 'turtle') {
            animal.swimTime += 0.02;
            animal.mesh.position.y = baseY + Math.sin(animal.swimTime) * 0.1;
            if (animal.mesh.flipperL) {
                animal.mesh.flipperL.rotation.z = Math.sin(animal.swimTime * 2) * 0.3;
                animal.mesh.flipperR.rotation.z = -Math.sin(animal.swimTime * 2) * 0.3;
            }
        } else if (animal.type === 'buoy') {
            animal.bobTime += 0.05;
            animal.mesh.position.y = 0.2 + Math.sin(animal.bobTime + (animal.mesh.userData.bobOffset || 0)) * 0.15;
            animal.mesh.rotation.z = Math.sin(animal.bobTime * 0.7) * 0.05;
        }
    });
    
    // Update confetti
    updateConfetti();
    
    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// === GAME LOGIC ===

function updateTimerDisplay() {
    const mins = Math.floor(remainingSeconds / 60);
    const secs = remainingSeconds % 60;
    document.getElementById('timer-display').textContent = 
        `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

let currentActivity = 'custom';
let needsSceneRebuild = false;

function selectTheme(theme) {
    if (theme !== selectedBiome) {
        selectedBiome = theme;
        
        // Update button selection
        document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('selected'));
        document.querySelector(`.theme-btn.${theme}`).classList.add('selected');
        
        // Rebuild scene immediately
        rebuildScene();
        
        // Update header
        updateHeader();
    }
}

function updateHeader() {
    const duckNames = {
        classic: 'Classic', chef: 'Chef', farmer: 'Farmer', construction: 'Builder',
        police: 'Officer', firefighter: 'Firefighter', doctor: 'Doctor', sailor: 'Sailor',
        pirate: 'Pirate', cowboy: 'Cowboy', wizard: 'Wizard', ninja: 'Ninja', astronaut: 'Astronaut'
    };
    const biomeEmoji = { forest: 'üå≤', desert: 'üèúÔ∏è', ocean: 'üåä', winter: '‚ùÑÔ∏è' };
    const headerText = `${biomeEmoji[selectedBiome] || 'ü¶Ü'} ${duckNames[selectedDuckType] || 'Duck'} ${selectedBiome === 'ocean' ? '‚õµ' : 'ü¶Ü'}`;
    document.querySelector('#header h1').textContent = headerText;
}

function rebuildScene() {
    // Clear existing scenery and animals
    scene.children = scene.children.filter(c => 
        c === camera || c.type === 'AmbientLight' || c.type === 'DirectionalLight'
    );
    animals = [];
    grassBlades = [];
    backgroundDucks = [];
    
    // Update sky/fog
    const biome = BIOME_CONFIG[selectedBiome];
    scene.background = new THREE.Color(biome.skyColor);
    scene.fog = new THREE.Fog(biome.fogColor, 50, 150);
    
    // Rebuild ground
    const groundTexture = createGroundTexture(selectedBiome);
    const groundGeo = new THREE.PlaneGeometry(200, 300, 100, 150);
    const positions = groundGeo.attributes.position;
    
    function noise(x, z) {
        if (selectedBiome === 'ocean') return 0;
        const scale = selectedBiome === 'desert' ? 0.5 : 1;
        return (Math.sin(x * 0.1) * Math.cos(z * 0.08) * 2 +
               Math.sin(x * 0.05 + z * 0.05) * 3 +
               Math.sin(x * 0.2) * Math.cos(z * 0.15) * 0.5) * scale;
    }
    
    for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const distFromPath = Math.abs(x);
        const pathFlatness = Math.max(0, 1 - distFromPath / 12);
        positions.setZ(i, noise(x, y) * (1 - pathFlatness));
    }
    groundGeo.computeVertexNormals();
    
    const groundMat = new THREE.MeshStandardMaterial({ 
        map: groundTexture,
        roughness: selectedBiome === 'ocean' ? 0.3 : 0.9,
        metalness: selectedBiome === 'ocean' ? 0.1 : 0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Water ponds for forest
    if (selectedBiome === 'forest') {
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x4A90D9, transparent: true, opacity: 0.7, roughness: 0.2 });
        [[-25, -30], [30, -70], [-28, -100]].forEach(([px, pz]) => {
            const pond = new THREE.Mesh(new THREE.CircleGeometry(5 + Math.random() * 3, 16), waterMat);
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(px, 0.1, pz);
            scene.add(pond);
        });
    }
    
    // Rebuild trail, duck, boat, scenery
    buildTrail(5);
    buildDuck();
    if (selectedBiome === 'ocean') buildBoat();
    else boat = null;
    buildScenery();
    if (selectedBiome !== 'ocean') addBackgroundDucks();
    
    needsSceneRebuild = false;
}

function showCustomInput() {
    document.getElementById('custom-input').style.display = 'block';
    document.getElementById('custom-minutes').focus();
}

function hideCustomInput() {
    document.getElementById('custom-input').style.display = 'none';
}

function startCustomActivity() {
    const minutes = parseInt(document.getElementById('custom-minutes').value) || 5;
    hideCustomInput();
    startActivity('custom', Math.min(60, Math.max(1, minutes)));
}

function startActivity(activity, minutes) {
    currentActivity = activity;
    
    // Initialize audio on first user interaction
    initAudio();
    
    // Rebuild scene if theme changed
    if (needsSceneRebuild) {
        rebuildScene();
    }
    
    startJourney(minutes);
}

function startJourney(minutes = 5) {
    totalSeconds = minutes * 60;
    remainingSeconds = totalSeconds;
    currentJourneyMinutes = minutes;
    
    // Rebuild world sized for this journey duration
    rebuildGround(minutes);
    
    // Rebuild trail for this duration
    buildTrail(minutes);
    
    // Reset duck to start (raised above terrain, or in boat for ocean)
    duck.position.copy(trail[0]);
    if (selectedBiome === 'ocean') {
        duck.position.y = 0.9;
        if (boat) {
            boat.position.copy(trail[0]);
            boat.position.y = 0.3;
            boat.rotation.y = 0;
        }
    } else {
        duck.position.y = getTerrainHeight(trail[0].x, trail[0].z) + 0.5;
    }
    duckBasePos.copy(duck.position);
    duck.rotation.y = 0;
    
    // Reset camera orbit (start lower and further back)
    camTheta = 0;
    camPhi = Math.PI / 3; // Lower on horizon
    camRadius = 20; // Further back
    
    // Reset auto-camera
    autoCameraEnabled = true;
    autoCamTime = 0;
    autoCamModeTimer = 0;
    autoCamMode = 'follow';
    autoCamTargetTheta = 0;
    autoCamTargetPhi = Math.PI / 3;
    autoCamTargetRadius = 20;
    
    state = 'journey';
    trailProgress = 0;
    journeyStartTime = Date.now();
    pausedTime = 0;
    lastQuackMinute = 0; // Reset quack tracker
    
    document.getElementById('setup-panel').style.display = 'none';
    document.getElementById('journey-controls').classList.add('visible');
    
    updateTimerDisplay();
    
    timerInterval = setInterval(() => {
        remainingSeconds--;
        updateTimerDisplay();
        
        if (remainingSeconds <= 0) {
            clearInterval(timerInterval);
            journeyComplete();
        }
    }, 1000);
}

let pauseStartTime = 0;
let isStartled = false;
let startledTime = 0;

function sleepDuck() {
    state = 'paused';
    clearInterval(timerInterval);
    pauseStartTime = Date.now();
    
    // Cinematic sleep: zoom to front of duck's face
    autoCameraEnabled = false;
    autoCamTargetTheta = duck.rotation.y; // In front of the duck (where it's facing)
    autoCamTargetPhi = Math.PI / 2.6; // Slightly higher to see face
    autoCamTargetRadius = 7; // Pull back a bit more
    
    document.getElementById('pause-btn').style.display = 'none';
    document.getElementById('resume-btn').style.display = 'block';
}

function wakeDuck() {
    // Ring the bell! Duck gets startled
    playBell();
    
    isStartled = true;
    startledTime = 0;
    state = 'startled';
    
    // Switch from bell back to sleep button
    document.getElementById('resume-btn').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'block';
    
    // After startled animation, resume journey
    setTimeout(() => {
        isStartled = false;
        
        // Update paused time BEFORE changing state so position calc is correct
        pausedTime += Date.now() - pauseStartTime;
        
        // Reset duck rotation from wobble
        duck.rotation.z = 0;
        duck.rotation.x = 0;
        
        // Sync duckBasePos to current position to prevent jump
        duckBasePos.copy(duck.position);
        
        // Re-enable auto camera in follow mode
        // Sync targets to CURRENT camera position so no sudden movement
        autoCameraEnabled = true;
        autoCamMode = 'follow';
        autoCamModeTimer = 0; // Will stay in follow mode for 8-14 seconds before switching
        autoCamTargetTheta = camTheta;
        autoCamTargetPhi = camPhi;
        autoCamTargetRadius = camRadius;
        
        // NOW switch state and start timer
        state = 'journey';
        
        timerInterval = setInterval(() => {
            remainingSeconds--;
            updateTimerDisplay();
            
            if (remainingSeconds <= 0) {
                clearInterval(timerInterval);
                journeyComplete();
            }
        }, 1000);
    }, 1200); // Startled animation lasts 1.2 seconds
}

function journeyComplete() {
    state = 'celebration';
    isDancing = true;
    
    // Party time! üéâ
    spawnConfetti();
    playCelebration();
    
    document.getElementById('journey-controls').classList.remove('visible');
    document.getElementById('celebration').classList.add('visible');
    
    // After 2 seconds, show reward panel
    setTimeout(() => {
        document.getElementById('celebration').classList.remove('visible');
        document.getElementById('reward-panel').classList.add('visible');
        state = 'reward';
    }, 2500);
}

// === DRAG & DROP REWARDS ===
let draggedReward = null;

document.querySelectorAll('.reward-item').forEach(item => {
    item.addEventListener('touchstart', startDrag);
    item.addEventListener('mousedown', startDrag);
});

function startDrag(e) {
    e.preventDefault();
    draggedReward = e.target.dataset.reward;
    e.target.classList.add('dragging');
    
    const dragEl = document.getElementById('drag-reward');
    dragEl.textContent = draggedReward;
    dragEl.classList.add('visible');
    
    moveDrag(e);
    
    document.addEventListener('touchmove', moveDrag);
    document.addEventListener('mousemove', moveDrag);
    document.addEventListener('touchend', endDrag);
    document.addEventListener('mouseup', endDrag);
}

function moveDrag(e) {
    const dragEl = document.getElementById('drag-reward');
    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    dragEl.style.left = x + 'px';
    dragEl.style.top = y + 'px';
}

function endDrag(e) {
    document.removeEventListener('touchmove', moveDrag);
    document.removeEventListener('mousemove', moveDrag);
    document.removeEventListener('touchend', endDrag);
    document.removeEventListener('mouseup', endDrag);
    
    document.getElementById('drag-reward').classList.remove('visible');
    document.querySelectorAll('.reward-item').forEach(i => i.classList.remove('dragging'));
    
    // Check if dropped on duck (upper portion of screen)
    const y = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
    if (y < window.innerHeight * 0.5 && draggedReward) {
        giveReward(draggedReward);
    }
    
    draggedReward = null;
}

const activityIcons = {
    toothbrush: 'ü™•',
    dress: 'üëï',
    tidy: 'üßπ',
    eat: 'üçΩÔ∏è',
    read: 'üìö',
    homework: '‚úèÔ∏è',
    calm: 'üßò',
    custom: '‚≠ê'
};

const activityNames = {
    toothbrush: 'Brush Teeth',
    dress: 'Get Dressed',
    tidy: 'Tidy Up',
    eat: 'Eat Meal',
    read: 'Reading',
    homework: 'Homework',
    calm: 'Calm Down',
    custom: 'Custom'
};

function giveReward(reward) {
    // Save reward with activity info
    weeklyRewards.push({
        emoji: reward,
        activity: currentActivity,
        date: new Date().toISOString()
    });
    localStorage.setItem('buddyRewards', JSON.stringify(weeklyRewards));
    
    // Duck celebrates more
    danceTime = 0;
    
    // Hide reward panel, show summary
    document.getElementById('reward-panel').classList.remove('visible');
    
    setTimeout(() => {
        showSummary();
    }, 1500);
}

function showSummary() {
    state = 'summary';
    isDancing = false;
    
    // Show last 7 days of rewards
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const recentRewards = weeklyRewards.filter(r => new Date(r.date).getTime() > weekAgo);
    
    const container = document.getElementById('rewards-chart');
    
    if (recentRewards.length === 0) {
        container.innerHTML = '<p style="text-align:center; color:#888;">No rewards yet!</p>';
    } else {
        // Show most recent first
        container.innerHTML = recentRewards.slice().reverse().map(r => {
            const activity = r.activity || 'custom';
            const icon = activityIcons[activity] || '‚≠ê';
            const name = activityNames[activity] || 'Activity';
            const date = new Date(r.date);
            const dateStr = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
            
            return `<div class="reward-row">
                <span class="activity-icon">${icon}</span>
                <span class="activity-name">${name}</span>
                <span class="reward-emoji">${r.emoji}</span>
                <span class="reward-date">${dateStr}</span>
            </div>`;
        }).join('');
    }
    
    // Show total count
    document.getElementById('total-rewards').textContent = 
        `üèÜ ${recentRewards.length} reward${recentRewards.length !== 1 ? 's' : ''} this week!`;
    
    document.getElementById('summary-panel').classList.add('visible');
}

// === HOLD-TO-RESET ===
let resetHoldTimer = null;
let resetStartTime = 0;
let resetAnimFrame = null;
const RESET_HOLD_DURATION = 2000; // 2 seconds

function initResetButton() {
    const btn = document.getElementById('reset-btn');
    const progress = document.getElementById('reset-progress');
    
    const startHold = (e) => {
        e.preventDefault();
        resetStartTime = Date.now();
        progress.style.opacity = '1';
        btn.style.transform = 'scale(0.95)';
        
        // Animate the progress ring
        const animateProgress = () => {
            const elapsed = Date.now() - resetStartTime;
            const percent = Math.min(elapsed / RESET_HOLD_DURATION, 1);
            const degrees = percent * 360;
            
            // Counter-clockwise: start from top (270deg) and go backwards
            progress.style.background = `conic-gradient(from 270deg, #CC3333 ${degrees}deg, transparent ${degrees}deg)`;
            
            if (percent >= 1) {
                // Held long enough - trigger reset
                cancelHold();
                resetToMenu();
            } else {
                resetAnimFrame = requestAnimationFrame(animateProgress);
            }
        };
        resetAnimFrame = requestAnimationFrame(animateProgress);
    };
    
    const cancelHold = () => {
        if (resetAnimFrame) {
            cancelAnimationFrame(resetAnimFrame);
            resetAnimFrame = null;
        }
        const progress = document.getElementById('reset-progress');
        const btn = document.getElementById('reset-btn');
        if (progress) {
            progress.style.opacity = '0';
            progress.style.background = 'conic-gradient(from 270deg, #CC3333 0deg, transparent 0deg)';
        }
        if (btn) btn.style.transform = 'scale(1)';
    };
    
    btn.addEventListener('mousedown', startHold);
    btn.addEventListener('touchstart', startHold, { passive: false });
    btn.addEventListener('mouseup', cancelHold);
    btn.addEventListener('mouseleave', cancelHold);
    btn.addEventListener('touchend', cancelHold);
    btn.addEventListener('touchcancel', cancelHold);
}

function resetToMenu() {
    // Stop current journey and go back to activity selection
    clearInterval(timerInterval);
    state = 'setup';
    isDancing = false;
    isStartled = false;
    trailProgress = 0;
    
    // Reset duck
    duck.position.copy(trail[0]);
    if (selectedBiome === 'ocean') {
        duck.position.y = 0.9;
        if (boat) {
            boat.position.copy(trail[0]);
            boat.position.y = 0.3;
        }
    } else {
        duck.position.y = getTerrainHeight(trail[0].x, trail[0].z) + 0.5;
    }
    duckBasePos.copy(duck.position);
    duck.rotation.set(0, 0, 0);
    
    // Reset camera
    camTheta = 0;
    camPhi = Math.PI / 3;
    camRadius = 20;
    autoCameraEnabled = true;
    
    // Reset UI
    document.getElementById('journey-controls').classList.remove('visible');
    document.getElementById('pause-btn').style.display = 'block';
    document.getElementById('resume-btn').style.display = 'none';
    document.getElementById('setup-panel').style.display = 'block';
    document.getElementById('timer-display').textContent = '--:--';
}

function resetApp() {
    state = 'setup';
    isDancing = false;
    trailProgress = 0;
    
    // Rebuild default trail (5 min default)
    buildTrail(5);
    
    // Reset duck position (raised above terrain, or in boat for ocean)
    duck.position.copy(trail[0]);
    if (selectedBiome === 'ocean') {
        duck.position.y = 0.9;
        if (boat) {
            boat.position.copy(trail[0]);
            boat.position.y = 0.3;
            boat.rotation.y = 0;
        }
    } else {
        duck.position.y = getTerrainHeight(trail[0].x, trail[0].z) + 0.5;
    }
    duckBasePos.copy(duck.position);
    duck.rotation.y = 0;
    
    // Reset camera orbit (start lower and further back)
    camTheta = 0;
    camPhi = Math.PI / 3;
    camRadius = 20;
    
    // Reset auto-camera for next journey
    autoCameraEnabled = true;
    autoCamTime = 0;
    autoCamModeTimer = 0;
    autoCamMode = 'follow';
    autoCamTargetTheta = 0;
    autoCamTargetPhi = Math.PI / 3;
    autoCamTargetRadius = 20;
    
    // Reset UI
    document.getElementById('summary-panel').classList.remove('visible');
    document.getElementById('setup-panel').style.display = 'block';
    document.getElementById('timer-display').textContent = '--:--';
}

// === INIT ===
initThree();
initResetButton();
updateHeader();
console.log('üéÆ Biome:', selectedBiome, '| Duck:', selectedDuckType);
</script>
</body>
</html>
