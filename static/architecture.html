<!DOCTYPE html>
<html>
<head>
    <title>SpeakFit Architecture - 3D View</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 15px; border-radius: 8px; max-width: 300px;
        }
        #info h3 { margin-top: 0; }
        #controls {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 10px; border-radius: 8px;
        }
        .layer-btn { margin: 2px; padding: 5px 10px; cursor: pointer; border-radius: 4px; border: none; }
    </style>
</head>
<body>
<div id="info">
    <h3>üèóÔ∏è SpeakFit Architecture</h3>
    <p id="hover-info">Hover over components to see details<br><br>
    <em>Drag to rotate ‚Ä¢ Scroll to zoom</em></p>
</div>
<div id="controls">
    <strong>Layers:</strong>
    <button class="layer-btn" style="background:#4CAF50" onclick="toggleLayer('app')">üì± App</button>
    <button class="layer-btn" style="background:#2196F3" onclick="toggleLayer('api')">‚ö° API</button>
    <button class="layer-btn" style="background:#FF9800" onclick="toggleLayer('pipeline')">üî¨ Pipeline</button>
    <button class="layer-btn" style="background:#9C27B0" onclick="toggleLayer('data')">üíæ Data</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// SpeakFit Architecture Data - derived from codebase analysis
const architecture = {
    app: {
        name: "Flutter App",
        color: 0x4CAF50,
        y: 15,
        components: [
            { name: "HomeScreen", size: 16, desc: "Main dashboard" },
            { name: "RecordScreen", size: 21, desc: "Audio recording UI" },
            { name: "ResultsScreen", size: 35, desc: "Analysis display" },
            { name: "CoachScreen", size: 10, desc: "AI speech coach" },
            { name: "HistoryScreen", size: 16, desc: "Past recordings" },
            { name: "ProjectsScreen", size: 13, desc: "Project management" },
            { name: "SettingsScreen", size: 21, desc: "User preferences" },
            { name: "APIService", size: 16, desc: "Backend communication" },
            { name: "AuthService", size: 8, desc: "Google/Apple sign-in" },
        ]
    },
    api: {
        name: "FastAPI Backend",
        color: 0x2196F3,
        y: 5,
        components: [
            { name: "main.py", size: 8, desc: "App entry, lifespan" },
            { name: "router.py", size: 85, desc: "All API endpoints" },
            { name: "pipeline_runner", size: 28, desc: "Analysis orchestration" },
            { name: "job_manager", size: 15, desc: "Async job queue" },
            { name: "auth", size: 9, desc: "API key auth" },
            { name: "user_auth", size: 12, desc: "JWT/OAuth" },
            { name: "rate_limiter", size: 6, desc: "Request throttling" },
        ]
    },
    pipeline: {
        name: "Analysis Pipeline",
        color: 0xFF9800,
        y: -5,
        components: [
            { name: "Whisper STT", size: 20, desc: "Speech-to-text (GPU)" },
            { name: "audio_analysis", size: 8, desc: "Pitch, jitter, shimmer" },
            { name: "audio_quality", size: 4, desc: "SNR, clipping detection" },
            { name: "advanced_audio", size: 13, desc: "Formants, vocal fry" },
            { name: "text_analysis", size: 4, desc: "Complexity, fluency" },
            { name: "advanced_text", size: 8, desc: "Readability, entities" },
            { name: "sentiment", size: 3, desc: "Emotion detection" },
            { name: "rhetorical", size: 5, desc: "Repetition, rhythm" },
            { name: "diarization", size: 16, desc: "Speaker identification" },
        ]
    },
    data: {
        name: "Data Layer",
        color: 0x9C27B0,
        y: -15,
        components: [
            { name: "SQLite DB", size: 52, desc: "11GB, 77K+ speeches" },
            { name: "speeches", size: 20, desc: "Recording metadata" },
            { name: "analyses", size: 15, desc: "Full analysis JSON" },
            { name: "users", size: 10, desc: "User accounts" },
            { name: "projects", size: 8, desc: "Project groupings" },
            { name: "audio_files", size: 30, desc: "Opus audio storage" },
        ]
    }
};

// Three.js setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(40, 30, 40);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const directional = new THREE.DirectionalLight(0xffffff, 0.8);
directional.position.set(20, 40, 20);
scene.add(directional);

// Grid helper
const grid = new THREE.GridHelper(60, 20, 0x444444, 0x333333);
grid.position.y = -20;
scene.add(grid);

// Create components
const objects = [];
const layers = {};
const labelSprites = [];

Object.entries(architecture).forEach(([layerKey, layer]) => {
    layers[layerKey] = [];
    const cols = Math.ceil(Math.sqrt(layer.components.length));
    
    layer.components.forEach((comp, i) => {
        const row = Math.floor(i / cols);
        const col = i % cols;
        
        const height = Math.max(1.5, comp.size / 8);
        const geometry = new THREE.BoxGeometry(3.5, height, 3.5);
        const material = new THREE.MeshPhongMaterial({ 
            color: layer.color,
            transparent: true,
            opacity: 0.85,
            shininess: 30
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(
            (col - cols/2) * 5.5,
            layer.y + height/2,
            (row - 1) * 5.5
        );
        mesh.userData = { 
            name: comp.name, 
            layer: layer.name,
            size: comp.size,
            desc: comp.desc,
            layerKey: layerKey
        };
        
        scene.add(mesh);
        objects.push(mesh);
        layers[layerKey].push(mesh);
        
        // Edges
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.4, transparent: true }));
        line.position.copy(mesh.position);
        scene.add(line);
        layers[layerKey].push(line);
    });
    
    // Layer platform
    const platformGeom = new THREE.BoxGeometry(35, 0.3, 25);
    const platformMat = new THREE.MeshPhongMaterial({ color: layer.color, opacity: 0.2, transparent: true });
    const platform = new THREE.Mesh(platformGeom, platformMat);
    platform.position.set(0, layer.y - 0.5, 0);
    scene.add(platform);
    layers[layerKey].push(platform);
    
    // Layer label
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, 512, 128);
    ctx.strokeStyle = '#' + layer.color.toString(16).padStart(6, '0');
    ctx.lineWidth = 4;
    ctx.strokeRect(2, 2, 508, 124);
    ctx.fillStyle = '#' + layer.color.toString(16).padStart(6, '0');
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(layer.name, 256, 80);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.scale.set(20, 5, 1);
    sprite.position.set(-25, layer.y + 2, 0);
    scene.add(sprite);
    layers[layerKey].push(sprite);
    labelSprites.push(sprite);
});

// Connection lines between layers
const createConnectionLine = (fromY, toY, xOffset = 0) => {
    const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(xOffset, fromY - 1, 0),
        new THREE.Vector3(xOffset + 5, (fromY + toY) / 2, 3),
        new THREE.Vector3(xOffset, toY + 1, 0)
    ]);
    const points = curve.getPoints(20);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ color: 0x888888, opacity: 0.6, transparent: true });
    return new THREE.Line(geometry, material);
};

scene.add(createConnectionLine(15, 5, -5));
scene.add(createConnectionLine(15, 5, 5));
scene.add(createConnectionLine(5, -5, -3));
scene.add(createConnectionLine(5, -5, 3));
scene.add(createConnectionLine(-5, -15, 0));
scene.add(createConnectionLine(5, -15, 10));

// Raycaster for hover
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredObject = null;

function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(objects);
    
    // Reset previous
    if (hoveredObject) {
        hoveredObject.material.emissive.setHex(0x000000);
        hoveredObject.scale.set(1, 1, 1);
    }
    
    const infoEl = document.getElementById('hover-info');
    if (intersects.length > 0) {
        const obj = intersects[0].object;
        const data = obj.userData;
        infoEl.innerHTML = `<strong>${data.name}</strong><br>
            Layer: ${data.layer}<br>
            Size: ${data.size}KB<br>
            <em>${data.desc}</em>`;
        obj.material.emissive.setHex(0x333333);
        obj.scale.set(1.1, 1.1, 1.1);
        hoveredObject = obj;
        document.body.style.cursor = 'pointer';
    } else {
        infoEl.innerHTML = 'Hover over components to see details<br><br><em>Drag to rotate ‚Ä¢ Scroll to zoom</em>';
        hoveredObject = null;
        document.body.style.cursor = 'default';
    }
}

window.addEventListener('mousemove', onMouseMove);

// Toggle layer visibility
window.toggleLayer = function(layerKey) {
    const visible = !layers[layerKey][0].visible;
    layers[layerKey].forEach(obj => obj.visible = visible);
    event.target.style.opacity = visible ? 1 : 0.4;
};

// Animation
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    // Labels always face camera
    labelSprites.forEach(sprite => {
        sprite.quaternion.copy(camera.quaternion);
    });
    
    renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
